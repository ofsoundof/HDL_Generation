{
  "design_name": "div_16bit",
  "trial_num": 10,
  "created_at": "2026-02-03T16:12:16.235250",
  "total_layers": 3,
  "layer_outputs": {
    "0": [
      {
        "code": "module div_16bit (\n    input [15:0] A,\n    input [7:0] B,\n    output reg [15:0] result,\n    output reg [15:0] odd\n);\n\nreg [15:0] a_reg;\nreg [7:0] b_reg;\nreg [15:0] shift;\n\nalways @(A or B) begin\n    a_reg <= A;\n    b_reg <= B;\nend\n\nalways @(A or B) begin\n    if (b_reg == 0)\n        result = 16'b0;\n    else begin\n        shift = {8'b0, a_reg};\n        result = 16'b0;\n        odd = a_reg % b_reg;\n        for (int i = 15; i >= 0; i--) begin\n            if (shift[i:i+7] >= b_reg) begin\n                result[i] = 1;\n                shift[i:i+7] = shift[i:i+7] - b_reg;\n            end\n        end\n    end\nend\n\nendmodule",
        "model": "qwen2.5-coder:7b",
        "quality_score": 0.6,
        "layer_idx": 0,
        "cached_at": "2026-02-03T16:12:31.713282",
        "generation_info": {
          "layer_idx": 0,
          "prompt_type": "initial",
          "generation_time": "2026-02-03T16:12:21.678460"
        }
      },
      {
        "code": "module div_16bit (\n    input [15:0] A,\n    input [7:0]  B,\n    output reg [15:0] result,\n    output reg [15:0] odd\n);\n    reg [15:0] a_reg;\n    reg [7:0] b_reg;\n    wire [23:0] temp;\n\n    always @(*) begin\n        a_reg = A;\n        b_reg = B;\n        temp = {a_reg[15:8], 8'b0};\n        if (temp >= b_reg) begin\n            result[15] = 1;\n            temp = temp - b_reg;\n        end else begin\n            result[15] = 0;\n        end\n    end\n\n    always @(*) begin\n        for (int i = 14; i >= 0; i--) begin\n            if (temp[23:8] >= b_reg) begin\n                result[i] = 1;\n                temp = {temp[7], temp[23:9] - b_reg};\n            end else begin\n                result[i] = 0;\n            end\n        end\n    end\n\n    always @(*) begin\n        odd = {temp, a_reg[7:0]};\n    end\nendmodule",
        "model": "qwen2.5-coder:7b",
        "quality_score": 0.6,
        "layer_idx": 0,
        "cached_at": "2026-02-03T16:12:31.713285",
        "generation_info": {
          "layer_idx": 0,
          "prompt_type": "initial",
          "generation_time": "2026-02-03T16:12:27.923273"
        }
      },
      {
        "code": "module div_16bit (\n    input [15:0] A,\n    input [7:0] B,\n    output reg [15:0] result,\n    output reg [15:0] odd\n);\n\nreg [23:0] dividend;\nreg [15:0] divisor;\nreg [4:0] quotient;\nwire [7:0] remainder;\n\nassign dividend = {A[15], A};\nassign divisor = B;\nassign remainder = dividend - (divisor << quotient);\nassign result = {quotient, 1'b0};\n\nalways @(*) begin\n    if (dividend >= divisor) begin\n        quotient = quotient + 1;\n        dividend = remainder;\n    end else begin\n        odd = remainder;\n    end\nend\n\nendmodule",
        "model": "qwen2.5-coder:7b",
        "quality_score": 0.6,
        "layer_idx": 0,
        "cached_at": "2026-02-03T16:12:31.713286",
        "generation_info": {
          "layer_idx": 0,
          "prompt_type": "initial",
          "generation_time": "2026-02-03T16:12:31.713270"
        }
      }
    ],
    "1": [
      {
        "code": "module div_16bit (\n    input [15:0] A,\n    input [7:0] B,\n    output reg [15:0] result,\n    output reg [15:0] odd\n);\n\nreg [23:0] dividend;\nreg [7:0] divisor;\nreg [15:0] quotient;\n\nalways @(*) begin\n    dividend = {A, 8'b0};\n    divisor = B;\n    quotient = 16'b0;\nend\n\nalways @(*) begin\n    for (int i = 15; i >= 0; i--) begin\n        if (dividend[i:i+7] >= divisor) begin\n            dividend[i:i+7] = dividend[i:i+7] - divisor;\n            quotient[i] = 1;\n        end\n    end\n    odd = {dividend[7:0], A[7:0]};\nend\n\nassign result = {quotient, 8'b0};\n\nendmodule",
        "model": "qwen2.5-coder:7b",
        "quality_score": 0.6,
        "layer_idx": 1,
        "cached_at": "2026-02-03T16:12:45.873956",
        "generation_info": {
          "layer_idx": 1,
          "prompt_type": "aggregation",
          "input_codes_quality": [
            0.6,
            0.6,
            0.6
          ],
          "generation_time": "2026-02-03T16:12:36.785215"
        }
      },
      {
        "code": "module div_16bit (\n    input [15:0] A,\n    input [7:0] B,\n    output reg [15:0] result,\n    output reg [15:0] odd\n);\n\nreg [15:0] a_reg;\nreg [7:0] b_reg;\nwire [23:0] shift;\n\nalways @(*) begin\n    a_reg = A;\n    b_reg = B;\n    shift = {8'b0, a_reg};\nend\n\nalways @(*) begin\n    result = 16'b0;\n    odd = a_reg % b_reg;\n    for (int i = 15; i >= 0; i--) begin\n        if (shift[i:i+7] >= b_reg) begin\n            result[i] = 1;\n            shift[i:i+7] = shift[i:i+7] - b_reg;\n        end\n    end\nend\n\nalways @(*) begin\n    odd = {a_reg[7:0], shift};\nend\n\nendmodule",
        "model": "qwen2.5-coder:7b",
        "quality_score": 0.6,
        "layer_idx": 1,
        "cached_at": "2026-02-03T16:12:45.873958",
        "generation_info": {
          "layer_idx": 1,
          "prompt_type": "aggregation",
          "input_codes_quality": [
            0.6,
            0.6,
            0.6
          ],
          "generation_time": "2026-02-03T16:12:42.003464"
        }
      },
      {
        "code": "module div_16bit (\n    input [15:0] A,\n    input [7:0] B,\n    output reg [15:0] result,\n    output reg [15:0] odd\n);\n\nreg [23:0] dividend;\nreg [7:0] divisor;\nreg [4:0] quotient;\nwire [7:0] remainder;\n\nassign dividend = {A[15], A};\nassign divisor = B;\nassign remainder = dividend - (divisor << quotient);\nassign result = {quotient, 8'b0};\n\nalways @(*) begin\n    if (dividend >= divisor) begin\n        quotient = quotient + 1;\n        dividend = remainder;\n    end else begin\n        odd = remainder;\n    end\nend\n\nendmodule",
        "model": "qwen2.5-coder:7b",
        "quality_score": 0.6,
        "layer_idx": 1,
        "cached_at": "2026-02-03T16:12:45.873959",
        "generation_info": {
          "layer_idx": 1,
          "prompt_type": "aggregation",
          "input_codes_quality": [
            0.6,
            0.6,
            0.6
          ],
          "generation_time": "2026-02-03T16:12:45.873942"
        }
      }
    ],
    "2": [
      {
        "code": "module div_16bit (\n    input [15:0] A,\n    input [7:0] B,\n    output reg [15:0] result,\n    output reg [15:0] odd\n);\n\nreg [15:0] a_reg;\nreg [7:0] b_reg;\nwire [23:0] shift;\n\nalways @(*) begin\n    a_reg = A;\n    b_reg = B;\n    shift = {8'b0, a_reg};\nend\n\nalways @(*) begin\n    result = 16'b0;\n    odd = a_reg % b_reg;\n    for (int i = 15; i >= 0; i--) begin\n        if (shift[i:i+7] >= b_reg) begin\n            result[i] = 1;\n            shift[i:i+7] = shift[i:i+7] - b_reg;\n        end\n    end\nend\n\nendmodule",
        "model": "qwen2.5-coder:7b",
        "quality_score": 0.6,
        "layer_idx": 2,
        "cached_at": "2026-02-03T16:13:00.191252",
        "generation_info": {
          "layer_idx": 2,
          "prompt_type": "aggregation",
          "input_codes_quality": [
            0.6,
            0.6,
            0.6
          ],
          "generation_time": "2026-02-03T16:12:50.796116"
        }
      },
      {
        "code": "module div_16bit (\n    input [15:0] A,\n    input [7:0] B,\n    output reg [15:0] result,\n    output reg [15:0] odd\n);\n\nreg [23:0] dividend;\nreg [7:0] divisor;\nwire [7:0] remainder;\n\nassign dividend = {A[15], A};\nassign divisor = B;\nassign remainder = dividend - (divisor << $countones(dividend >> 8));\n\nalways @(*) begin\n    if (dividend >= divisor) begin\n        result = {result, 1'b1};\n        dividend = remainder;\n    end else begin\n        odd = remainder;\n        result = {result, 1'b0};\n    end\nend\n\nendmodule",
        "model": "qwen2.5-coder:7b",
        "quality_score": 0.6,
        "layer_idx": 2,
        "cached_at": "2026-02-03T16:13:00.191255",
        "generation_info": {
          "layer_idx": 2,
          "prompt_type": "aggregation",
          "input_codes_quality": [
            0.6,
            0.6,
            0.6
          ],
          "generation_time": "2026-02-03T16:12:54.816443"
        }
      },
      {
        "code": "module div_16bit (\n    input [15:0] A,\n    input [7:0]  B,\n    output reg [15:0] result,\n    output reg [15:0] odd\n);\n\nreg [23:0] a_reg;\nreg [7:0] b_reg;\nreg [15:0] remainder;\nreg [15:0] quotient;\n\nalways @(*) begin\n    a_reg = A;\n    b_reg = B;\nend\n\nalways @(*) begin\n    if (b_reg == 0) begin\n        result = 16'b0;\n        odd = a_reg;\n    end else begin\n        remainder = a_reg;\n        quotient = 16'b0;\n        for (int i = 15; i >= 0; i--) begin\n            if (remainder[23:8] >= b_reg) begin\n                quotient[i] = 1;\n                remainder = {remainder[7], remainder[23:9]} - b_reg;\n            end else begin\n                remainder = {remainder[7], remainder[23:9]};\n            end\n        end\n        odd = {remainder, a_reg[7:0]};\n    end\nend\n\nendmodule",
        "model": "qwen2.5-coder:7b",
        "quality_score": 0.85,
        "layer_idx": 2,
        "cached_at": "2026-02-03T16:13:00.191256",
        "generation_info": {
          "layer_idx": 2,
          "prompt_type": "aggregation",
          "input_codes_quality": [
            0.6,
            0.6,
            0.6
          ],
          "generation_time": "2026-02-03T16:13:00.191239"
        }
      }
    ]
  },
  "metadata": {
    "last_updated": "2026-02-03T16:13:00.191261",
    "total_hdl_codes": 9
  }
}