{
  "design_name": "sequence_detector",
  "trial_num": 1,
  "created_at": "2026-02-03T16:50:50.352362",
  "total_layers": 3,
  "layer_outputs": {
    "0": [
      {
        "code": "module sequence_detector(clk, reset_n, data_in, sequence_detected);\n  input clk, reset_n, data_in;\n  output reg sequence_detected;\n\n  reg [1:0] state, next_state;\n\n  parameter IDLE = 2'b00, S1 = 2'b01, S2 = 2'b10, S3 = 2'b11;\n\n  always @(posedge clk or negedge reset_n) begin\n    if (!reset_n)\n      state <= IDLE;\n    else\n      state <= next_state;\n  end\n\n  always @(*) begin\n    next_state = state;\n    sequence_detected = 0;\n\n    case (state)\n      IDLE: begin\n        if (data_in == 1'b1)\n          next_state = S1;\n      end\n      S1: begin\n        if (data_in == 1'b0)\n          next_state = S2;\n        else\n          next_state = IDLE;\n      end\n      S2: begin\n        if (data_in == 1'b0)\n          next_state = S3;\n        else\n          next_state = IDLE;\n      end\n      S3: begin\n        if (data_in == 1'b1) begin\n          next_state = IDLE;\n          sequence_detected = 1;\n        end else\n          next_state = IDLE;\n      end\n    endcase\n  end\n\nendmodule",
        "model": "qwen2.5-coder:7b",
        "quality_score": 0.75,
        "layer_idx": 0,
        "cached_at": "2026-02-03T16:51:10.015950",
        "generation_info": {
          "layer_idx": 0,
          "prompt_type": "initial",
          "generation_time": "2026-02-03T16:50:56.700650"
        }
      },
      {
        "code": "module sequence_detector (\n    input wire clk,\n    input wire reset_n,\n    input wire data_in,\n    output reg sequence_detected\n);\n\n    parameter [1:0] IDLE = 2'b00;\n    parameter [1:0] S1   = 2'b01;\n    parameter [1:0] S2   = 2'b10;\n    parameter [1:0] S3   = 2'b11;\n\n    reg [1:0] state, next_state;\n\n    always @(posedge clk or negedge reset_n) begin\n        if (!reset_n)\n            state <= IDLE;\n        else\n            state <= next_state;\n    end\n\n    always @(*) begin\n        next_state = state;\n        sequence_detected = 1'b0;\n\n        case (state)\n            IDLE:\n                if (data_in == 1'b1) begin\n                    next_state = S1;\n                end\n            S1:\n                if (data_in == 1'b0) begin\n                    next_state = S2;\n                end else begin\n                    next_state = IDLE;\n                end\n            S2:\n                if (data_in == 1'b0) begin\n                    next_state = S3;\n                end else begin\n                    next_state = IDLE;\n                end\n            S3:\n                if (data_in == 1'b1) begin\n                    next_state = IDLE;\n                    sequence_detected = 1'b1;\n                end else begin\n                    next_state = IDLE;\n                end\n        endcase\n    end\n\nendmodule",
        "model": "qwen2.5-coder:7b",
        "quality_score": 0.75,
        "layer_idx": 0,
        "cached_at": "2026-02-03T16:51:10.015952",
        "generation_info": {
          "layer_idx": 0,
          "prompt_type": "initial",
          "generation_time": "2026-02-03T16:51:03.754735"
        }
      },
      {
        "code": "module sequence_detector (\n    input wire clk,\n    input wire reset_n,\n    input wire data_in,\n    output reg sequence_detected\n);\n\nreg [1:0] state;\nlocalparam IDLE = 2'b00, S1 = 2'b01, S2 = 2'b10, S3 = 2'b11;\n\nalways @(posedge clk or negedge reset_n) begin\n    if (!reset_n) begin\n        state <= IDLE;\n        sequence_detected <= 0;\n    end else begin\n        case (state)\n            IDLE: begin\n                if (data_in == 1'b1) begin\n                    state <= S1;\n                end\n            end\n            S1: begin\n                if (data_in == 1'b0) begin\n                    state <= S2;\n                end else begin\n                    state <= IDLE;\n                end\n            end\n            S2: begin\n                if (data_in == 1'b0) begin\n                    state <= S3;\n                end else begin\n                    state <= IDLE;\n                end\n            end\n            S3: begin\n                if (data_in == 1'b1) begin\n                    sequence_detected <= 1;\n                    state <= IDLE;\n                end else begin\n                    state <= IDLE;\n                end\n            end\n        endcase\n    end\nend\n\nendmodule",
        "model": "qwen2.5-coder:7b",
        "quality_score": 0.75,
        "layer_idx": 0,
        "cached_at": "2026-02-03T16:51:10.015954",
        "generation_info": {
          "layer_idx": 0,
          "prompt_type": "initial",
          "generation_time": "2026-02-03T16:51:10.015936"
        }
      }
    ],
    "1": [
      {
        "code": "module sequence_detector(clk, reset_n, data_in, sequence_detected);\n  input clk, reset_n, data_in;\n  output reg sequence_detected;\n\n  reg [1:0] state, next_state;\n\n  parameter IDLE = 2'b00, S1 = 2'b01, S2 = 2'b10, S3 = 2'b11;\n\n  always @(posedge clk or negedge reset_n) begin\n    if (!reset_n)\n      state <= IDLE;\n    else\n      state <= next_state;\n  end\n\n  always @(*) begin\n    next_state = state;\n    sequence_detected = 0;\n\n    case (state)\n      IDLE: begin\n        if (data_in == 1'b1)\n          next_state = S1;\n      end\n      S1: begin\n        if (data_in == 1'b0)\n          next_state = S2;\n        else\n          next_state = IDLE;\n      end\n      S2: begin\n        if (data_in == 1'b0)\n          next_state = S3;\n        else\n          next_state = IDLE;\n      end\n      S3: begin\n        if (data_in == 1'b1) begin\n          next_state = IDLE;\n          sequence_detected = 1;\n        end else\n          next_state = IDLE;\n      end\n    endcase\n  end\n\nendmodule",
        "model": "qwen2.5-coder:7b",
        "quality_score": 0.75,
        "layer_idx": 1,
        "cached_at": "2026-02-03T16:51:29.535112",
        "generation_info": {
          "layer_idx": 1,
          "prompt_type": "aggregation",
          "input_codes_quality": [
            0.75,
            0.75,
            0.75
          ],
          "generation_time": "2026-02-03T16:51:16.541077"
        }
      },
      {
        "code": "module sequence_detector(\n    input wire clk,\n    input wire reset_n,\n    input wire data_in,\n    output reg sequence_detected\n);\n\nparameter [1:0] IDLE = 2'b00, S1 = 2'b01, S2 = 2'b10, S3 = 2'b11;\n\nreg [1:0] state;\nalways @(posedge clk or negedge reset_n) begin\n    if (!reset_n) begin\n        state <= IDLE;\n        sequence_detected <= 0;\n    end else begin\n        case (state)\n            IDLE: begin\n                if (data_in == 1'b1) begin\n                    state <= S1;\n                end\n            end\n            S1: begin\n                if (data_in == 1'b0) begin\n                    state <= S2;\n                end else begin\n                    state <= IDLE;\n                end\n            end\n            S2: begin\n                if (data_in == 1'b0) begin\n                    state <= S3;\n                end else begin\n                    state <= IDLE;\n                end\n            end\n            S3: begin\n                if (data_in == 1'b1) begin\n                    sequence_detected <= 1;\n                    state <= IDLE;\n                end else begin\n                    state <= IDLE;\n                end\n            end\n        endcase\n    end\nend\n\nendmodule",
        "model": "qwen2.5-coder:7b",
        "quality_score": 0.75,
        "layer_idx": 1,
        "cached_at": "2026-02-03T16:51:29.535114",
        "generation_info": {
          "layer_idx": 1,
          "prompt_type": "aggregation",
          "input_codes_quality": [
            0.75,
            0.75,
            0.75
          ],
          "generation_time": "2026-02-03T16:51:23.003313"
        }
      },
      {
        "code": "module sequence_detector(clk, reset_n, data_in, sequence_detected);\n  input clk, reset_n, data_in;\n  output reg sequence_detected;\n\n  reg [1:0] state, next_state;\n  \n  parameter IDLE = 2'b00, S1 = 2'b01, S2 = 2'b10, S3 = 2'b11;\n\n  always @(posedge clk or negedge reset_n) begin\n    if (!reset_n)\n      state <= IDLE;\n    else\n      state <= next_state;\n  end\n\n  always @(*) begin\n    next_state = state;\n    sequence_detected = 0;\n\n    case (state)\n      IDLE: begin\n        if (data_in == 1'b1)\n          next_state = S1;\n      end\n      S1: begin\n        if (data_in == 1'b0)\n          next_state = S2;\n        else\n          next_state = IDLE;\n      end\n      S2: begin\n        if (data_in == 1'b0)\n          next_state = S3;\n        else\n          next_state = IDLE;\n      end\n      S3: begin\n        if (data_in == 1'b1) begin\n          next_state = IDLE;\n          sequence_detected = 1;\n        end else\n          next_state = IDLE;\n      end\n    endcase\n  end\n\nendmodule",
        "model": "qwen2.5-coder:7b",
        "quality_score": 0.75,
        "layer_idx": 1,
        "cached_at": "2026-02-03T16:51:29.535115",
        "generation_info": {
          "layer_idx": 1,
          "prompt_type": "aggregation",
          "input_codes_quality": [
            0.75,
            0.75,
            0.75
          ],
          "generation_time": "2026-02-03T16:51:29.535097"
        }
      }
    ],
    "2": [
      {
        "code": "module sequence_detector(clk, reset_n, data_in, sequence_detected);\n  input clk, reset_n, data_in;\n  output reg sequence_detected;\n\n  reg [1:0] state, next_state;\n\n  parameter IDLE = 2'b00, S1 = 2'b01, S2 = 2'b10, S3 = 2'b11;\n\n  always @(posedge clk or negedge reset_n) begin\n    if (!reset_n)\n      state <= IDLE;\n    else\n      state <= next_state;\n  end\n\n  always @(*) begin\n    next_state = state;\n    sequence_detected = 0;\n\n    case (state)\n      IDLE: begin\n        if (data_in == 1'b1)\n          next_state = S1;\n      end\n      S1: begin\n        if (data_in == 1'b0)\n          next_state = S2;\n        else\n          next_state = IDLE;\n      end\n      S2: begin\n        if (data_in == 1'b0)\n          next_state = S3;\n        else\n          next_state = IDLE;\n      end\n      S3: begin\n        if (data_in == 1'b1) begin\n          next_state = IDLE;\n          sequence_detected = 1;\n        end else\n          next_state = IDLE;\n      end\n    endcase\n  end\n\nendmodule",
        "model": "qwen2.5-coder:7b",
        "quality_score": 0.75,
        "layer_idx": 2,
        "cached_at": "2026-02-03T16:51:49.114994",
        "generation_info": {
          "layer_idx": 2,
          "prompt_type": "aggregation",
          "input_codes_quality": [
            0.75,
            0.75,
            0.75
          ],
          "generation_time": "2026-02-03T16:51:36.062616"
        }
      },
      {
        "code": "module sequence_detector(clk, reset_n, data_in, sequence_detected);\n  input clk, reset_n, data_in;\n  output reg sequence_detected;\n\n  reg [1:0] state, next_state;\n  localparam IDLE = 2'b00, S1 = 2'b01, S2 = 2'b10, S3 = 2'b11;\n\n  always @(posedge clk or negedge reset_n) begin\n    if (!reset_n)\n      state <= IDLE;\n    else\n      state <= next_state;\n  end\n\n  always @(*) begin\n    next_state = state;\n    sequence_detected = 0;\n\n    case (state)\n      IDLE: begin\n        if (data_in == 1'b1)\n          next_state = S1;\n      end\n      S1: begin\n        if (data_in == 1'b0)\n          next_state = S2;\n        else\n          next_state = IDLE;\n      end\n      S2: begin\n        if (data_in == 1'b0)\n          next_state = S3;\n        else\n          next_state = IDLE;\n      end\n      S3: begin\n        if (data_in == 1'b1) begin\n          next_state = IDLE;\n          sequence_detected = 1;\n        end else\n          next_state = IDLE;\n      end\n    endcase\n  end\n\nendmodule",
        "model": "qwen2.5-coder:7b",
        "quality_score": 0.75,
        "layer_idx": 2,
        "cached_at": "2026-02-03T16:51:49.114997",
        "generation_info": {
          "layer_idx": 2,
          "prompt_type": "aggregation",
          "input_codes_quality": [
            0.75,
            0.75,
            0.75
          ],
          "generation_time": "2026-02-03T16:51:42.635324"
        }
      },
      {
        "code": "module sequence_detector (\n    input wire clk,\n    input wire reset_n,\n    input wire data_in,\n    output reg sequence_detected\n);\n\nreg [1:0] state;\nlocalparam IDLE = 2'b00, S1 = 2'b01, S2 = 2'b10, S3 = 2'b11;\n\nalways @(posedge clk or negedge reset_n) begin\n    if (!reset_n) begin\n        state <= IDLE;\n        sequence_detected <= 0;\n    end else begin\n        case (state)\n            IDLE: begin\n                if (data_in == 1'b1) begin\n                    state <= S1;\n                end\n            end\n            S1: begin\n                if (data_in == 1'b0) begin\n                    state <= S2;\n                end else begin\n                    state <= IDLE;\n                end\n            end\n            S2: begin\n                if (data_in == 1'b0) begin\n                    state <= S3;\n                end else begin\n                    state <= IDLE;\n                end\n            end\n            S3: begin\n                if (data_in == 1'b1) begin\n                    sequence_detected <= 1;\n                    state <= IDLE;\n                end else begin\n                    state <= IDLE;\n                end\n            end\n        endcase\n    end\nend\n\nendmodule",
        "model": "qwen2.5-coder:7b",
        "quality_score": 0.75,
        "layer_idx": 2,
        "cached_at": "2026-02-03T16:51:49.114998",
        "generation_info": {
          "layer_idx": 2,
          "prompt_type": "aggregation",
          "input_codes_quality": [
            0.75,
            0.75,
            0.75
          ],
          "generation_time": "2026-02-03T16:51:49.114981"
        }
      }
    ]
  },
  "metadata": {
    "last_updated": "2026-02-03T16:51:49.115004",
    "total_hdl_codes": 9
  }
}