{
  "design_name": "fixed_point_adder",
  "trial_num": 1,
  "created_at": "2026-02-03T16:39:16.978338",
  "total_layers": 3,
  "layer_outputs": {
    "0": [
      {
        "code": "module fixed_point_adder #(parameter Q = 8, parameter N = Q + 1)(input [N-1:0] a, input [N-1:0] b, output reg [N-1:0] c);\n    wire [N-1:0] abs_a, abs_b;\n    wire [N-2:0] sum, diff;\n    wire carry_out;\n\n    assign abs_a = a[Q] ? ~a + 1 : a;\n    assign abs_b = b[Q] ? ~b + 1 : b;\n\n    adder #(N) my_adder (.op1(abs_a), .op2(abs_b), .sum(sum), .carry_out(carry_out));\n    subtractor #(N-1) my_subtractor (.op1(abs_a), .op2(abs_b), .diff(diff));\n\n    always @(*) begin\n        if (a[Q] == b[Q]) begin\n            c = {!(a[Q]), sum};\n        end else if (sum >= diff) begin\n            c = {0, sum - diff};\n        end else begin\n            c = {b[Q], diff - sum};\n        end\n    end\nendmodule",
        "model": "qwen2.5-coder:7b",
        "quality_score": 0.6,
        "layer_idx": 0,
        "cached_at": "2026-02-03T16:39:26.958580",
        "generation_info": {
          "layer_idx": 0,
          "prompt_type": "initial",
          "generation_time": "2026-02-03T16:39:24.393989"
        }
      },
      {
        "code": "module fixed_point_adder #(parameter Q = 8, parameter N = 16) (\n    input [N-1:0] a,\n    input [N-1:0] b,\n    output reg [N-1:0] c\n);\n\nreg [N-1:0] abs_a;\nreg [N-1:0] abs_b;\nreg sign_c;\n\nalways @(*) begin\n    abs_a = (a[0]) ? (~a + 1) : a; // Calculate absolute value of a\n    abs_b = (b[0]) ? (~b + 1) : b; // Calculate absolute value of b\n\n    if (a[0] == b[0]) begin\n        c = abs_a + abs_b;\n        sign_c = a[0];\n    end else begin\n        if (abs_a > abs_b) begin\n            c = abs_a - abs_b;\n            sign_c = 1'b0;\n        end else begin\n            c = abs_b - abs_a;\n            sign_c = a[0];\n        end\n    end\n\n    // Ensure the result fits within N bits\n    if (c[N] == 1'b1) begin\n        c = ~c + 1;\n        sign_c = ~sign_c;\n    end\n\n    c[N-1] = sign_c; // Set the sign bit\nend\n\nendmodule",
        "model": "qwen2.5-coder:7b",
        "quality_score": 1.0,
        "layer_idx": 0,
        "cached_at": "2026-02-03T16:39:26.958582",
        "generation_info": {
          "layer_idx": 0,
          "prompt_type": "initial",
          "generation_time": "2026-02-03T16:39:25.996957"
        }
      },
      {
        "code": "module fixed_point_adder #(parameter Q = 8, parameter N = 16) (\n    input [N-1:0] a,\n    input [N-1:0] b,\n    output reg [N-1:0] c\n);\n\nreg [N:0] res;\nwire sign_a, sign_b, sign_res;\n\nassign sign_a = a[N-1];\nassign sign_b = b[N-1];\n\nalways @(*) begin\n    if (sign_a == sign_b) begin\n        res = a + b;\n    end else begin\n        if (a > b) begin\n            res = a - b;\n        end else begin\n            res = b - a;\n        end\n    end\nend\n\nassign c = {res[N], res[N-1:0]};\n\nendmodule",
        "model": "qwen2.5-coder:7b",
        "quality_score": 1.0,
        "layer_idx": 0,
        "cached_at": "2026-02-03T16:39:26.958583",
        "generation_info": {
          "layer_idx": 0,
          "prompt_type": "initial",
          "generation_time": "2026-02-03T16:39:26.958567"
        }
      }
    ],
    "1": [
      {
        "code": "module fixed_point_adder #(parameter Q = 8, parameter N = 16) (\n    input [N-1:0] a,\n    input [N-1:0] b,\n    output reg [N-1:0] c\n);\n\nreg [N-1:0] abs_a;\nreg [N-1:0] abs_b;\nreg sign_c;\n\nalways @(*) begin\n    abs_a = (a[N-1]) ? (~a + 1) : a; // Calculate absolute value of a\n    abs_b = (b[N-1]) ? (~b + 1) : b; // Calculate absolute value of b\n\n    if (a[N-1] == b[N-1]) begin\n        c = abs_a + abs_b;\n        sign_c = a[N-1];\n    end else begin\n        if (abs_a > abs_b) begin\n            c = abs_a - abs_b;\n            sign_c = 1'b0;\n        end else begin\n            c = abs_b - abs_a;\n            sign_c = a[N-1];\n        end\n    end\n\n    // Ensure the result fits within N bits\n    if (c[N] == 1'b1) begin\n        c = ~c + 1;\n        sign_c = ~sign_c;\n    end\n\n    c[N-1] = sign_c; // Set the sign bit\nend\n\nendmodule",
        "model": "qwen2.5-coder:7b",
        "quality_score": 1.0,
        "layer_idx": 1,
        "cached_at": "2026-02-03T16:39:31.811774",
        "generation_info": {
          "layer_idx": 1,
          "prompt_type": "aggregation",
          "input_codes_quality": [
            1.0,
            1.0,
            0.6
          ],
          "generation_time": "2026-02-03T16:39:28.675065"
        }
      },
      {
        "code": "module fixed_point_adder #(parameter Q = 8, parameter N = 16) (\n    input [N-1:0] a,\n    input [N-1:0] b,\n    output reg [N-1:0] c\n);\n\nreg [N-1:0] abs_a;\nreg [N-1:0] abs_b;\nreg sign_c;\n\nalways @(*) begin\n    abs_a = (a[0]) ? (~a + 1) : a; // Calculate absolute value of a\n    abs_b = (b[0]) ? (~b + 1) : b; // Calculate absolute value of b\n\n    if (a[0] == b[0]) begin\n        c = abs_a + abs_b;\n        sign_c = a[0];\n    end else begin\n        if (abs_a > abs_b) begin\n            c = abs_a - abs_b;\n            sign_c = 1'b0;\n        end else begin\n            c = abs_b - abs_a;\n            sign_c = a[0];\n        end\n    end\n\n    // Ensure the result fits within N bits\n    if (c[N] == 1'b1) begin\n        c = ~c + 1;\n        sign_c = ~sign_c;\n    end\n\n    c[N-1] = sign_c; // Set the sign bit\nend\n\nendmodule",
        "model": "qwen2.5-coder:7b",
        "quality_score": 1.0,
        "layer_idx": 1,
        "cached_at": "2026-02-03T16:39:31.811777",
        "generation_info": {
          "layer_idx": 1,
          "prompt_type": "aggregation",
          "input_codes_quality": [
            1.0,
            1.0,
            0.6
          ],
          "generation_time": "2026-02-03T16:39:30.229890"
        }
      },
      {
        "code": "module fixed_point_adder #(parameter Q = 8, parameter N = 16) (\n    input [N-1:0] a,\n    input [N-1:0] b,\n    output reg [N-1:0] c\n);\n\nreg [N-1:0] abs_a;\nreg [N-1:0] abs_b;\nreg sign_c;\n\nalways @(*) begin\n    abs_a = (a[N-1]) ? (~a + 1) : a; // Calculate absolute value of a\n    abs_b = (b[N-1]) ? (~b + 1) : b; // Calculate absolute value of b\n\n    if (a[N-1] == b[N-1]) begin\n        c = abs_a + abs_b;\n        sign_c = a[N-1];\n    end else begin\n        if (abs_a > abs_b) begin\n            c = abs_a - abs_b;\n            sign_c = 1'b0;\n        end else begin\n            c = abs_b - abs_a;\n            sign_c = a[N-1];\n        end\n    end\n\n    // Ensure the result fits within N bits\n    if (c[N] == 1'b1) begin\n        c = ~c + 1;\n        sign_c = ~sign_c;\n    end\n\n    c[N-1] = sign_c; // Set the sign bit\nend\n\nendmodule",
        "model": "qwen2.5-coder:7b",
        "quality_score": 1.0,
        "layer_idx": 1,
        "cached_at": "2026-02-03T16:39:31.811778",
        "generation_info": {
          "layer_idx": 1,
          "prompt_type": "aggregation",
          "input_codes_quality": [
            1.0,
            1.0,
            0.6
          ],
          "generation_time": "2026-02-03T16:39:31.811761"
        }
      }
    ],
    "2": [
      {
        "code": "module fixed_point_adder #(parameter Q = 8, parameter N = 16) (\n    input [N-1:0] a,\n    input [N-1:0] b,\n    output reg [N-1:0] c\n);\n\nreg [N-1:0] abs_a;\nreg [N-1:0] abs_b;\nreg sign_c;\n\nalways @(*) begin\n    abs_a = (a[N-1]) ? (~a + 1) : a; // Calculate absolute value of a\n    abs_b = (b[N-1]) ? (~b + 1) : b; // Calculate absolute value of b\n\n    if (a[N-1] == b[N-1]) begin\n        c = abs_a + abs_b;\n        sign_c = a[N-1];\n    end else begin\n        if (abs_a > abs_b) begin\n            c = abs_a - abs_b;\n            sign_c = 1'b0;\n        end else begin\n            c = abs_b - abs_a;\n            sign_c = a[N-1];\n        end\n    end\n\n    // Ensure the result fits within N bits\n    if (c[N] == 1'b1) begin\n        c = ~c + 1;\n        sign_c = ~sign_c;\n    end\n\n    c[N-1] = sign_c; // Set the sign bit\nend\n\nendmodule",
        "model": "qwen2.5-coder:7b",
        "quality_score": 1.0,
        "layer_idx": 2,
        "cached_at": "2026-02-03T16:39:36.608328",
        "generation_info": {
          "layer_idx": 2,
          "prompt_type": "aggregation",
          "input_codes_quality": [
            1.0,
            1.0,
            1.0
          ],
          "generation_time": "2026-02-03T16:39:33.437818"
        }
      },
      {
        "code": "module fixed_point_adder #(parameter Q = 8, parameter N = 16) (\n    input [N-1:0] a,\n    input [N-1:0] b,\n    output reg [N-1:0] c\n);\n\nreg [N-1:0] abs_a;\nreg [N-1:0] abs_b;\nreg sign_c;\n\nalways @(*) begin\n    abs_a = (a[N-1]) ? (~a + 1) : a; // Calculate absolute value of a\n    abs_b = (b[N-1]) ? (~b + 1) : b; // Calculate absolute value of b\n\n    if (a[N-1] == b[N-1]) begin\n        c = abs_a + abs_b;\n        sign_c = a[N-1];\n    end else begin\n        if (abs_a > abs_b) begin\n            c = abs_a - abs_b;\n            sign_c = 1'b0;\n        end else begin\n            c = abs_b - abs_a;\n            sign_c = a[N-1];\n        end\n    end\n\n    // Ensure the result fits within N bits\n    if (c[N] == 1'b1) begin\n        c = ~c + 1;\n        sign_c = ~sign_c;\n    end\n\n    c[N-1] = sign_c; // Set the sign bit\nend\n\nendmodule",
        "model": "qwen2.5-coder:7b",
        "quality_score": 1.0,
        "layer_idx": 2,
        "cached_at": "2026-02-03T16:39:36.608331",
        "generation_info": {
          "layer_idx": 2,
          "prompt_type": "aggregation",
          "input_codes_quality": [
            1.0,
            1.0,
            1.0
          ],
          "generation_time": "2026-02-03T16:39:35.019511"
        }
      },
      {
        "code": "module fixed_point_adder #(parameter Q = 8, parameter N = 16) (\n    input [N-1:0] a,\n    input [N-1:0] b,\n    output reg [N-1:0] c\n);\n\nreg [N-1:0] abs_a;\nreg [N-1:0] abs_b;\nreg sign_c;\n\nalways @(*) begin\n    abs_a = (a[N-1]) ? (~a + 1) : a; // Calculate absolute value of a\n    abs_b = (b[N-1]) ? (~b + 1) : b; // Calculate absolute value of b\n\n    if (a[N-1] == b[N-1]) begin\n        c = abs_a + abs_b;\n        sign_c = a[N-1];\n    end else begin\n        if (abs_a > abs_b) begin\n            c = abs_a - abs_b;\n            sign_c = 1'b0;\n        end else begin\n            c = abs_b - abs_a;\n            sign_c = a[N-1];\n        end\n    end\n\n    // Ensure the result fits within N bits\n    if (c[N] == 1'b1) begin\n        c = ~c + 1;\n        sign_c = ~sign_c;\n    end\n\n    c[N-1] = sign_c; // Set the sign bit\nend\n\nendmodule",
        "model": "qwen2.5-coder:7b",
        "quality_score": 1.0,
        "layer_idx": 2,
        "cached_at": "2026-02-03T16:39:36.608332",
        "generation_info": {
          "layer_idx": 2,
          "prompt_type": "aggregation",
          "input_codes_quality": [
            1.0,
            1.0,
            1.0
          ],
          "generation_time": "2026-02-03T16:39:36.608314"
        }
      }
    ]
  },
  "metadata": {
    "last_updated": "2026-02-03T16:39:36.608338",
    "total_hdl_codes": 9
  }
}