{
  "design_name": "div_16bit",
  "trial_num": 8,
  "created_at": "2026-02-03T16:10:39.370283",
  "total_layers": 3,
  "layer_outputs": {
    "0": [
      {
        "code": "module div_16bit (\n    input [15:0] A,\n    input [7:0] B,\n    output reg [15:0] result,\n    output reg [15:0] odd\n);\nreg [15:0] a_reg;\nreg [7:0] b_reg;\n\nalways @(*) begin\n    a_reg <= A;\n    b_reg <= B;\nend\n\nalways @(*) begin\n    if (a_reg[15:8] >= b_reg) begin\n        result[0] = 1'b1;\n        odd = a_reg[15:8] - b_reg;\n    end else begin\n        result[0] = 1'b0;\n        odd = a_reg[15:8];\n    end\n\n    if (odd >= b_reg) begin\n        result[1] = 1'b1;\n        odd -= b_reg;\n    end else begin\n        result[1] = 1'b0;\n    end\n\n    // Repeat the process for all bits of the dividend\n    assign result[2:15] = a_reg[13:8];\nend\n\nendmodule",
        "model": "qwen2.5-coder:7b",
        "quality_score": 0.6,
        "layer_idx": 0,
        "cached_at": "2026-02-03T16:10:54.506717",
        "generation_info": {
          "layer_idx": 0,
          "prompt_type": "initial",
          "generation_time": "2026-02-03T16:10:44.433958"
        }
      },
      {
        "code": "module div_16bit (\n    input [15:0] A,\n    input [7:0]  B,\n    output reg [15:0] result,\n    output reg [15:0] odd\n);\nreg [15:0] a_reg;\nreg [7:0] b_reg;\n\nalways @(*) begin\n    a_reg = A;\n    b_reg = B;\nend\n\nalways @(*) begin\n    if (b_reg == 0) begin\n        result = 16'b0;\n        odd = a_reg;\n    end else begin\n        reg [23:0] quotient;\n        reg [23:0] remainder;\n        int i;\n        quotient = 24'b0;\n        remainder = {8'b0, a_reg};\n        \n        for (i = 15; i >= 0; i--) begin\n            if (remainder[i + 7:8] >= b_reg) begin\n                remainder[i + 7:8] -= b_reg;\n                quotient[i] = 1'b1;\n            end\n        end\n        \n        result = {quotient[15:0], 8'b0};\n        odd = remainder[15:0];\n    end\nend\n\nendmodule",
        "model": "qwen2.5-coder:7b",
        "quality_score": 0.6,
        "layer_idx": 0,
        "cached_at": "2026-02-03T16:10:54.506719",
        "generation_info": {
          "layer_idx": 0,
          "prompt_type": "initial",
          "generation_time": "2026-02-03T16:10:50.198451"
        }
      },
      {
        "code": "module div_16bit (\n    input wire [15:0] A,\n    input wire [7:0] B,\n    output reg [15:0] result,\n    output reg [15:0] odd\n);\n\nalways @(*) begin\n    reg [15:0] a_reg, b_reg;\n    reg [15:0] quotient = 0;\n    reg [15:0] remainder = 0;\n    \n    a_reg = A;\n    b_reg = B;\n    \n    for (int i = 15; i >= 8; i--) begin\n        if (remainder[7:0] >= b_reg) begin\n            quotient[i - 8] = 1;\n            remainder[7:0] = remainder[7:0] - b_reg;\n        end\n        remainder = {1'b0, remainder[15:8]};\n    end\n    \n    result = quotient;\n    odd = remainder;\nend\n\nendmodule",
        "model": "qwen2.5-coder:7b",
        "quality_score": 0.85,
        "layer_idx": 0,
        "cached_at": "2026-02-03T16:10:54.506721",
        "generation_info": {
          "layer_idx": 0,
          "prompt_type": "initial",
          "generation_time": "2026-02-03T16:10:54.506704"
        }
      }
    ],
    "1": [
      {
        "code": "module div_16bit (\n    input wire [15:0] A,\n    input wire [7:0] B,\n    output reg [15:0] result,\n    output reg [15:0] odd\n);\n\nreg [15:0] a_reg;\nreg [7:0] b_reg;\n\nalways @(*) begin\n    a_reg = A;\n    b_reg = B;\nend\n\nalways @(*) begin\n    if (b_reg == 0) begin\n        result = 16'b0;\n        odd = a_reg;\n    end else begin\n        reg [23:0] quotient;\n        reg [23:0] remainder;\n        int i;\n        quotient = 24'b0;\n        remainder = {8'b0, a_reg};\n        \n        for (i = 15; i >= 0; i--) begin\n            if (remainder[i + 7:8] >= b_reg) begin\n                remainder[i + 7:8] -= b_reg;\n                quotient[i] = 1'b1;\n            end\n        end\n        \n        result = {quotient[15:0], 8'b0};\n        odd = remainder[15:0];\n    end\nend\n\nendmodule",
        "model": "qwen2.5-coder:7b",
        "quality_score": 0.6,
        "layer_idx": 1,
        "cached_at": "2026-02-03T16:11:12.133287",
        "generation_info": {
          "layer_idx": 1,
          "prompt_type": "aggregation",
          "input_codes_quality": [
            0.85,
            0.6,
            0.6
          ],
          "generation_time": "2026-02-03T16:11:00.401990"
        }
      },
      {
        "code": "module div_16bit (\n    input wire [15:0] A,\n    input wire [7:0] B,\n    output reg [15:0] result,\n    output reg [15:0] odd\n);\nreg [15:0] a_reg;\nreg [7:0] b_reg;\n\nalways @(*) begin\n    a_reg = A;\n    b_reg = B;\nend\n\nalways @(*) begin\n    if (a_reg[15:8] >= b_reg) begin\n        result[0] = 1'b1;\n        odd = a_reg[15:8] - b_reg;\n    end else begin\n        result[0] = 1'b0;\n        odd = a_reg[15:8];\n    end\n\n    if (odd >= b_reg) begin\n        result[1] = 1'b1;\n        odd -= b_reg;\n    end else begin\n        result[1] = 1'b0;\n    end\n\n    // Repeat the process for all bits of the dividend\n    assign result[2:15] = a_reg[13:8];\nend\n\nendmodule",
        "model": "qwen2.5-coder:7b",
        "quality_score": 0.6,
        "layer_idx": 1,
        "cached_at": "2026-02-03T16:11:12.133290",
        "generation_info": {
          "layer_idx": 1,
          "prompt_type": "aggregation",
          "input_codes_quality": [
            0.85,
            0.6,
            0.6
          ],
          "generation_time": "2026-02-03T16:11:06.194105"
        }
      },
      {
        "code": "module div_16bit (\n    input wire [15:0] A,\n    input wire [7:0] B,\n    output reg [15:0] result,\n    output reg [15:0] odd\n);\nreg [15:0] a_reg;\nreg [7:0] b_reg;\n\nalways @(*) begin\n    a_reg = A;\n    b_reg = B;\nend\n\nalways @(*) begin\n    if (b_reg == 0) begin\n        result = 16'b0;\n        odd = a_reg;\n    end else begin\n        reg [23:0] quotient;\n        reg [23:0] remainder;\n        int i;\n        quotient = 24'b0;\n        remainder = {8'b0, a_reg};\n        \n        for (i = 15; i >= 0; i--) begin\n            if (remainder[i + 7:8] >= b_reg) begin\n                remainder[i + 7:8] -= b_reg;\n                quotient[i] = 1'b1;\n            end\n        end\n        \n        result = {quotient[15:0], 8'b0};\n        odd = remainder[15:0];\n    end\nend\n\nendmodule",
        "model": "qwen2.5-coder:7b",
        "quality_score": 0.6,
        "layer_idx": 1,
        "cached_at": "2026-02-03T16:11:12.133291",
        "generation_info": {
          "layer_idx": 1,
          "prompt_type": "aggregation",
          "input_codes_quality": [
            0.85,
            0.6,
            0.6
          ],
          "generation_time": "2026-02-03T16:11:12.133274"
        }
      }
    ],
    "2": [
      {
        "code": "module div_16bit (\n    input wire [15:0] A,\n    input wire [7:0] B,\n    output reg [15:0] result,\n    output reg [15:0] odd\n);\n\nalways @(*) begin\n    reg [15:0] a_reg, b_reg;\n    reg [15:0] quotient = 0;\n    reg [15:0] remainder = 0;\n    \n    a_reg = A;\n    b_reg = B;\n    \n    for (int i = 15; i >= 8; i--) begin\n        if (remainder[7:0] >= b_reg) begin\n            quotient[i - 8] = 1;\n            remainder[7:0] = remainder[7:0] - b_reg;\n        end\n        remainder = {1'b0, remainder[15:8]};\n    end\n    \n    result = quotient;\n    odd = remainder;\nend\n\nendmodule",
        "model": "qwen2.5-coder:7b",
        "quality_score": 0.85,
        "layer_idx": 2,
        "cached_at": "2026-02-03T16:11:28.666413",
        "generation_info": {
          "layer_idx": 2,
          "prompt_type": "aggregation",
          "input_codes_quality": [
            0.85,
            0.6,
            0.6
          ],
          "generation_time": "2026-02-03T16:11:17.183546"
        }
      },
      {
        "code": "module div_16bit (\n    input wire [15:0] A,\n    input wire [7:0] B,\n    output reg [15:0] result,\n    output reg [15:0] odd\n);\n\nreg [15:0] a_reg;\nreg [7:0] b_reg;\n\nalways @(*) begin\n    a_reg = A;\n    b_reg = B;\nend\n\nalways @(*) begin\n    if (b_reg == 0) begin\n        result = 16'b0;\n        odd = a_reg;\n    end else begin\n        reg [23:0] quotient = 24'b0;\n        reg [23:0] remainder = {8'b0, a_reg};\n        \n        for (int i = 15; i >= 8; i--) begin\n            if (remainder[i + 7:8] >= b_reg) begin\n                remainder[i + 7:8] -= b_reg;\n                quotient[i] = 1'b1;\n            end\n        end\n        \n        result = {quotient[15:0], 8'b0};\n        odd = remainder[15:7];\n    end\nend\n\nendmodule",
        "model": "qwen2.5-coder:7b",
        "quality_score": 0.6,
        "layer_idx": 2,
        "cached_at": "2026-02-03T16:11:28.666416",
        "generation_info": {
          "layer_idx": 2,
          "prompt_type": "aggregation",
          "input_codes_quality": [
            0.85,
            0.6,
            0.6
          ],
          "generation_time": "2026-02-03T16:11:22.938344"
        }
      },
      {
        "code": "module div_16bit (\n    input [15:0] A,\n    input [7:0]  B,\n    output reg [15:0] result,\n    output reg [15:0] odd\n);\nreg [15:0] a_reg;\nreg [7:0] b_reg;\n\nalways @(*) begin\n    a_reg = A;\n    b_reg = B;\nend\n\nalways @(*) begin\n    if (b_reg == 0) begin\n        result = 16'b0;\n        odd = a_reg;\n    end else begin\n        reg [15:0] quotient = 0;\n        reg [15:0] remainder = {8'b0, a_reg};\n        \n        for (int i = 15; i >= 0; i--) begin\n            if (remainder[i + 7:8] >= b_reg) begin\n                remainder[i + 7:8] -= b_reg;\n                quotient[i] = 1'b1;\n            end\n        end\n        \n        result = {quotient, 8'b0};\n        odd = remainder[15:0];\n    end\nend\n\nendmodule",
        "model": "qwen2.5-coder:7b",
        "quality_score": 0.6,
        "layer_idx": 2,
        "cached_at": "2026-02-03T16:11:28.666417",
        "generation_info": {
          "layer_idx": 2,
          "prompt_type": "aggregation",
          "input_codes_quality": [
            0.85,
            0.6,
            0.6
          ],
          "generation_time": "2026-02-03T16:11:28.666397"
        }
      }
    ]
  },
  "metadata": {
    "last_updated": "2026-02-03T16:11:28.666423",
    "total_hdl_codes": 9
  }
}