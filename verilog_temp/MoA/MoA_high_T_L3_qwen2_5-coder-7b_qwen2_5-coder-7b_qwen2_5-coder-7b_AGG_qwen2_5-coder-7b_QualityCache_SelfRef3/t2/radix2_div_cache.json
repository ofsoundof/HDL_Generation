{
  "design_name": "radix2_div",
  "trial_num": 2,
  "created_at": "2026-02-03T16:14:41.103258",
  "total_layers": 3,
  "layer_outputs": {
    "0": [
      {
        "code": "module radix2_div (\n    input clk,\n    input rst,\n    input sign,\n    input [7:0] dividend,\n    input [7:0] divisor,\n    input opn_valid,\n    output reg res_valid,\n    output reg [15:0] result\n);\n    reg [7:0] abs_dividend;\n    reg [7:0] abs_divisor;\n    reg [8:0] SR;\n    reg [7:0] NEG_DIVISOR;\n    reg [2:0] cnt, start_cnt;\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            result <= 16'b0;\n            res_valid <= 1'b0;\n            SR <= 9'b0;\n            abs_dividend <= 8'b0;\n            abs_divisor <= 8'b0;\n            NEG_DIVISOR <= 8'b0;\n            cnt <= 3'b0;\n            start_cnt <= 3'b0;\n        end else begin\n            if (opn_valid && !res_valid) begin\n                abs_dividend <= sign ? -dividend : dividend;\n                abs_divisor <= sign ? -divisor : divisor;\n                NEG_DIVISOR <= ~abs_divisor + 1;\n                SR <= {abs_dividend, 1'b0};\n                cnt <= 3'b001;\n                start_cnt <= 3'b001;\n            end else if (start_cnt) begin\n                if (cnt[2]) begin\n                    SR <= {SR[7:0], 1'b0};\n                    cnt <= cnt - 1;\n                end else begin\n                    start_cnt <= 3'b0;\n                    res_valid <= 1'b1;\n                    result <= {SR, abs_dividend / abs_divisor};\n                end\n            end\n        end\n    end\n\nendmodule",
        "model": "qwen2.5-coder:7b",
        "quality_score": 0.6399999999999999,
        "layer_idx": 0,
        "cached_at": "2026-02-03T16:15:08.900998",
        "generation_info": {
          "layer_idx": 0,
          "prompt_type": "initial",
          "generation_time": "2026-02-03T16:14:49.312903"
        }
      },
      {
        "code": "module radix2_div (\n    input clk,\n    input rst,\n    input sign,\n    input [7:0] dividend,\n    input [7:0] divisor,\n    input opn_valid,\n    output reg res_valid,\n    output reg [15:0] result\n);\n\n    reg [7:0] ABS_DIVIDEND;\n    reg [7:0] ABS_DIVISOR;\n    reg [8:0] SR;\n    reg [3:0] cnt, start_cnt;\n\n    wire [7:0] sub_result;\n    wire carry_out;\n    reg [15:0] tmp_result;\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            res_valid <= 0;\n            result <= 0;\n            ABS_DIVIDEND <= 0;\n            ABS_DIVISOR <= 0;\n            SR <= 0;\n            cnt <= 0;\n            start_cnt <= 0;\n            tmp_result <= 0;\n        end else if (opn_valid && !res_valid) begin\n            if (sign == 1'b1) begin\n                ABS_DIVIDEND <= dividend[7] ? -dividend : dividend;\n                ABS_DIVISOR <= divisor[7] ? -divisor : divisor;\n            } else begin\n                ABS_DIVIDEND <= dividend;\n                ABS_DIVISOR <= divisor;\n            end\n            SR <= {ABS_DIVIDEND, 1'b0};\n            NEG_DIVISOR <= ABS_DIVISOR;\n            cnt <= 4'd1;\n            start_cnt <= 4'd1;\n            res_valid <= 0;\n        end else if (start_cnt) begin\n            if (cnt == 4'd8) begin\n                SR <= {ABS_DIVIDEND, 1'b0};\n                cnt <= 4'd0;\n                start_cnt <= 0;\n                tmp_result[7:0] <= SR[7:0];\n                tmp_result[15:8] <= SR[15:8];\n                res_valid <= 1;\n            end else begin\n                sub_result <= SR - ABS_DIVISOR;\n                carry_out <= ~sub_result[0];\n                if (carry_out) begin\n                    SR <= {SR[7:1], carry_out};\n                end else begin\n                    SR <= {SR[6:0], 1'b0, 1'b1};\n                end\n                cnt <= cnt + 4'd1;\n            end\n        end\n    end\n\nendmodule",
        "model": "qwen2.5-coder:7b",
        "quality_score": 0.6,
        "layer_idx": 0,
        "cached_at": "2026-02-03T16:15:08.901001",
        "generation_info": {
          "layer_idx": 0,
          "prompt_type": "initial",
          "generation_time": "2026-02-03T16:14:59.767083"
        }
      },
      {
        "code": "module radix2_div (\n    input wire clk,\n    input wire rst,\n    input wire sign,\n    input wire [7:0] dividend,\n    input wire [7:0] divisor,\n    input wire opn_valid,\n    output reg res_valid,\n    output reg [15:0] result\n);\n\n    reg [15:0] SR;\n    reg [7:0] ABS_DIVISOR;\n    reg [7:0] NEG_DIVISOR;\n    reg [2:0] cnt;\n    reg start_cnt;\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            res_valid <= 0;\n            SR <= 0;\n            ABS_DIVISOR <= 0;\n            NEG_DIVISOR <= 0;\n            cnt <= 3'b000;\n            start_cnt <= 0;\n            result <= 16'b0;\n        end else if (opn_valid && !res_valid) begin\n            SR <= {dividend, 1'b0};\n            ABS_DIVISOR <= sign ? ~divisor + 1 : divisor;\n            NEG_DIVISOR <= sign ? -ABS_DIVISOR : ABS_DIVISOR;\n            cnt <= 3'b001;\n            start_cnt <= 1;\n        end else if (start_cnt) begin\n            if (cnt == 8'b1000) begin\n                SR[7:0] <= SR[6:0];\n                NEG_DIVISOR <= sign ? ~divisor + 1 : divisor;\n                res_valid <= 1;\n                result <= {SR, ABS_DIVISOR};\n            end else begin\n                SR[7:0] <= SR[6:0] - NEG_DIVISOR;\n                if (SR[8]) begin\n                    SR[7:0] <= SR[6:0] - NEG_DIVISOR;\n                end\n                SR[7:0] <= SR[6:0];\n                cnt <= cnt + 3'b001;\n            end\n        end\n    end\n\nendmodule",
        "model": "qwen2.5-coder:7b",
        "quality_score": 0.59,
        "layer_idx": 0,
        "cached_at": "2026-02-03T16:15:08.901002",
        "generation_info": {
          "layer_idx": 0,
          "prompt_type": "initial",
          "generation_time": "2026-02-03T16:15:08.900985"
        }
      }
    ],
    "1": [
      {
        "code": "module radix2_div (\n    input wire clk,\n    input wire rst,\n    input wire sign,\n    input wire [7:0] dividend,\n    input wire [7:0] divisor,\n    input wire opn_valid,\n    output reg res_valid,\n    output reg [15:0] result\n);\n\n    reg [8:0] SR;\n    reg [7:0] ABS_DIVISOR, NEG_DIVISOR;\n    reg [2:0] cnt;\n    reg start_cnt;\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            res_valid <= 0;\n            SR <= 9'b0;\n            ABS_DIVISOR <= 8'b0;\n            NEG_DIVISOR <= 8'b0;\n            cnt <= 3'b000;\n            start_cnt <= 1'b0;\n            result <= 16'b0;\n        end else if (opn_valid && !res_valid) begin\n            ABS_DIVISOR <= sign ? -divisor : divisor;\n            NEG_DIVISOR <= ~ABS_DIVISOR + 1;\n            SR <= {sign ? -dividend : dividend, 1'b0};\n            cnt <= 3'b001;\n            start_cnt <= 1'b0;\n        end else if (start_cnt) begin\n            if (cnt == 8'b1000) begin\n                SR[7:0] <= SR[6:0];\n                NEG_DIVISOR <= sign ? -divisor : divisor;\n                res_valid <= 1;\n                result <= {SR, ABS_DIVISOR};\n            end else begin\n                SR[7:0] <= SR[6:0] - NEG_DIVISOR;\n                if (SR[8]) begin\n                    SR[7:0] <= SR[6:0] - NEG_DIVISOR;\n                end\n                SR[7:0] <= SR[6:0];\n                cnt <= cnt + 3'b001;\n            end\n        end\n    end\n\nendmodule",
        "model": "qwen2.5-coder:7b",
        "quality_score": 0.48999999999999994,
        "layer_idx": 1,
        "cached_at": "2026-02-03T16:15:36.889709",
        "generation_info": {
          "layer_idx": 1,
          "prompt_type": "aggregation",
          "input_codes_quality": [
            0.6399999999999999,
            0.6,
            0.59
          ],
          "generation_time": "2026-02-03T16:15:18.287112"
        }
      },
      {
        "code": "module radix2_div (\n    input wire clk,\n    input wire rst,\n    input wire sign,\n    input wire [7:0] dividend,\n    input wire [7:0] divisor,\n    input wire opn_valid,\n    output reg res_valid,\n    output reg [15:0] result\n);\n\n    reg [7:0] ABS_DIVIDEND;\n    reg [7:0] ABS_DIVISOR;\n    reg [8:0] SR;\n    reg [2:0] cnt, start_cnt;\n\n    wire [7:0] sub_result;\n    wire carry_out;\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            res_valid <= 0;\n            result <= 0;\n            ABS_DIVIDEND <= 0;\n            ABS_DIVISOR <= 0;\n            SR <= 0;\n            cnt <= 0;\n            start_cnt <= 0;\n        end else if (opn_valid && !res_valid) begin\n            ABS_DIVIDEND <= sign ? -dividend : dividend;\n            ABS_DIVISOR <= sign ? -divisor : divisor;\n            NEG_DIVISOR <= ~ABS_DIVISOR + 1;\n            SR <= {ABS_DIVIDEND, 1'b0};\n            cnt <= 3'b001;\n            start_cnt <= 3'b001;\n        end else if (start_cnt) begin\n            if (cnt == 8'b1000) begin\n                start_cnt <= 0;\n                res_valid <= 1;\n                result <= {SR[7:0], ABS_DIVISOR};\n            end else begin\n                sub_result <= SR - ABS_DIVISOR;\n                carry_out <= ~sub_result[0];\n                if (carry_out) begin\n                    SR[7:0] <= SR[6:0];\n                end else begin\n                    SR[7:0] <= {SR[6:1], 1'b1};\n                end\n                cnt <= cnt + 3'b001;\n            end\n        end\n    end\n\nendmodule",
        "model": "qwen2.5-coder:7b",
        "quality_score": 0.6,
        "layer_idx": 1,
        "cached_at": "2026-02-03T16:15:36.889711",
        "generation_info": {
          "layer_idx": 1,
          "prompt_type": "aggregation",
          "input_codes_quality": [
            0.6399999999999999,
            0.6,
            0.59
          ],
          "generation_time": "2026-02-03T16:15:27.769605"
        }
      },
      {
        "code": "module radix2_div (\n    input clk,\n    input rst,\n    input sign,\n    input [7:0] dividend,\n    input [7:0] divisor,\n    input opn_valid,\n    output reg res_valid,\n    output reg [15:0] result\n);\n\nreg [8:0] SR;\nreg [7:0] ABS_DIVISOR;\nreg [7:0] NEG_DIVISOR;\nreg [2:0] cnt, start_cnt;\n\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        res_valid <= 1'b0;\n        SR <= 9'b0;\n        ABS_DIVISOR <= 8'b0;\n        NEG_DIVISOR <= 8'b0;\n        cnt <= 3'b0;\n        start_cnt <= 3'b0;\n        result <= 16'b0;\n    end else if (opn_valid && !res_valid) begin\n        ABS_DIVISOR <= sign ? -divisor : divisor;\n        SR <= {sign ? -dividend : dividend, 1'b0};\n        NEG_DIVISOR <= ~ABS_DIVISOR + 1;\n        cnt <= 3'b001;\n        start_cnt <= 3'b001;\n    end else if (start_cnt) begin\n        if (cnt == 8'b1000) begin\n            SR[7:0] <= SR[6:0];\n            NEG_DIVISOR <= sign ? -divisor : divisor;\n            res_valid <= 1'b1;\n            result <= {SR, ABS_DIVISOR};\n        end else begin\n            if (SR[8]) begin\n                SR <= {SR[7:0], 1'b0} - ABS_DIVISOR;\n            end else begin\n                SR <= {SR[7:0] - NEG_DIVISOR, 1'b0};\n            end\n            cnt <= cnt + 3'b001;\n        end\n    end\nend\n\nendmodule",
        "model": "qwen2.5-coder:7b",
        "quality_score": 0.48999999999999994,
        "layer_idx": 1,
        "cached_at": "2026-02-03T16:15:36.889712",
        "generation_info": {
          "layer_idx": 1,
          "prompt_type": "aggregation",
          "input_codes_quality": [
            0.6399999999999999,
            0.6,
            0.59
          ],
          "generation_time": "2026-02-03T16:15:36.889695"
        }
      }
    ],
    "2": [
      {
        "code": "module radix2_div (\n    input clk,\n    input rst,\n    input sign,\n    input [7:0] dividend,\n    input [7:0] divisor,\n    input opn_valid,\n    output reg res_valid,\n    output reg [15:0] result\n);\n\n    reg [7:0] ABS_DIVIDEND;\n    reg [7:0] ABS_DIVISOR;\n    reg [8:0] SR;\n    reg [2:0] cnt, start_cnt;\n\n    wire [7:0] sub_result;\n    wire carry_out;\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            res_valid <= 0;\n            result <= 0;\n            ABS_DIVIDEND <= 0;\n            ABS_DIVISOR <= 0;\n            SR <= 0;\n            cnt <= 0;\n            start_cnt <= 0;\n        end else if (opn_valid && !res_valid) begin\n            ABS_DIVIDEND <= sign ? -dividend : dividend;\n            ABS_DIVISOR <= sign ? -divisor : divisor;\n            NEG_DIVISOR <= ~ABS_DIVISOR + 1;\n            SR <= {ABS_DIVIDEND, 1'b0};\n            cnt <= 3'b001;\n            start_cnt <= 3'b001;\n        end else if (start_cnt) begin\n            if (cnt == 8'b1000) begin\n                start_cnt <= 0;\n                res_valid <= 1;\n                result <= {SR[7:0], SR[15:8]};\n            end else begin\n                sub_result <= SR - ABS_DIVISOR;\n                carry_out <= ~sub_result[0];\n                if (carry_out) begin\n                    SR <= {SR[7:0], 1'b0};\n                end else begin\n                    SR <= {SR[6:0], 1'b1, 1'b0};\n                end\n                cnt <= cnt + 3'b001;\n            end\n        end\n    end\n\nendmodule",
        "model": "qwen2.5-coder:7b",
        "quality_score": 0.6,
        "layer_idx": 2,
        "cached_at": "2026-02-03T16:16:04.140472",
        "generation_info": {
          "layer_idx": 2,
          "prompt_type": "aggregation",
          "input_codes_quality": [
            0.6399999999999999,
            0.6,
            0.6
          ],
          "generation_time": "2026-02-03T16:15:45.907681"
        }
      },
      {
        "code": "module radix2_div (\n    input wire clk,\n    input wire rst,\n    input wire sign,\n    input wire [7:0] dividend,\n    input wire [7:0] divisor,\n    input wire opn_valid,\n    output reg res_valid,\n    output reg [15:0] result\n);\n\n    reg [7:0] ABS_DIVIDEND;\n    reg [7:0] ABS_DIVISOR;\n    reg [8:0] SR;\n    reg [2:0] cnt, start_cnt;\n\n    wire [7:0] sub_result;\n    wire carry_out;\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            res_valid <= 0;\n            result <= 0;\n            ABS_DIVIDEND <= 0;\n            ABS_DIVISOR <= 0;\n            SR <= 0;\n            cnt <= 3'b000;\n            start_cnt <= 3'b000;\n        end else if (opn_valid && !res_valid) begin\n            ABS_DIVIDEND <= sign ? -dividend : dividend;\n            ABS_DIVISOR <= sign ? -divisor : divisor;\n            SR <= {ABS_DIVIDEND, 1'b0};\n            cnt <= 3'b001;\n            start_cnt <= 3'b001;\n        end else if (start_cnt) begin\n            sub_result <= SR - ABS_DIVISOR;\n            carry_out <= ~sub_result[7];\n            SR <= {SR[6:0], carry_out, sub_result[6]};\n            cnt <= cnt + 3'b001;\n            if (cnt == 8'b1000) begin\n                start_cnt <= 3'b000;\n                res_valid <= 1;\n                result <= {SR[7:0], ABS_DIVISOR};\n            end\n        end\n    end\n\nendmodule",
        "model": "qwen2.5-coder:7b",
        "quality_score": 0.6,
        "layer_idx": 2,
        "cached_at": "2026-02-03T16:16:04.140475",
        "generation_info": {
          "layer_idx": 2,
          "prompt_type": "aggregation",
          "input_codes_quality": [
            0.6399999999999999,
            0.6,
            0.6
          ],
          "generation_time": "2026-02-03T16:15:54.643736"
        }
      },
      {
        "code": "module radix2_div (\n    input wire clk,\n    input wire rst,\n    input wire sign,\n    input wire [7:0] dividend,\n    input wire [7:0] divisor,\n    input wire opn_valid,\n    output reg res_valid,\n    output reg [15:0] result\n);\n\n    reg [7:0] ABS_DIVIDEND;\n    reg [7:0] ABS_DIVISOR;\n    reg [8:0] SR;\n    reg [2:0] cnt, start_cnt;\n    wire [7:0] sub_result;\n    wire carry_out;\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            res_valid <= 0;\n            result <= 0;\n            ABS_DIVIDEND <= 0;\n            ABS_DIVISOR <= 0;\n            SR <= 0;\n            cnt <= 3'b000;\n            start_cnt <= 3'b000;\n        end else if (opn_valid && !res_valid) begin\n            ABS_DIVIDEND <= sign ? -dividend : dividend;\n            ABS_DIVISOR <= sign ? -divisor : divisor;\n            NEG_DIVISOR <= ~ABS_DIVISOR + 1;\n            SR <= {ABS_DIVIDEND, 1'b0};\n            cnt <= 3'b001;\n            start_cnt <= 3'b001;\n        end else if (start_cnt) begin\n            if (cnt == 8'b1000) begin\n                start_cnt <= 0;\n                res_valid <= 1;\n                result <= {SR[7:0], ABS_DIVISOR};\n            end else begin\n                sub_result <= SR - ABS_DIVISOR;\n                carry_out <= ~sub_result[0];\n                if (carry_out) begin\n                    SR[7:0] <= SR[6:0];\n                end else begin\n                    SR[7:0] <= {SR[6:1], 1'b1};\n                end\n                cnt <= cnt + 3'b001;\n            end\n        end\n    end\n\nendmodule",
        "model": "qwen2.5-coder:7b",
        "quality_score": 0.6,
        "layer_idx": 2,
        "cached_at": "2026-02-03T16:16:04.140476",
        "generation_info": {
          "layer_idx": 2,
          "prompt_type": "aggregation",
          "input_codes_quality": [
            0.6399999999999999,
            0.6,
            0.6
          ],
          "generation_time": "2026-02-03T16:16:04.140458"
        }
      }
    ]
  },
  "metadata": {
    "last_updated": "2026-02-03T16:16:04.140482",
    "total_hdl_codes": 9
  }
}