{
  "design_name": "div_16bit",
  "trial_num": 2,
  "created_at": "2026-02-03T16:05:47.596059",
  "total_layers": 3,
  "layer_outputs": {
    "0": [
      {
        "code": "module div_16bit (\n    input  [15:0] A,\n    input  [7:0] B,\n    output reg [15:0] result,\n    output reg [15:0] odd\n);\n\nreg [15:0] a_reg;\nreg [7:0] b_reg;\nreg [16:0] quotient;\nreg [16:0] remainder;\n\nalways @(*) begin\n    a_reg = A;\n    b_reg = B;\nend\n\nalways @(*) begin\n    quotient = 0;\n    remainder = 0;\n    for (int i = 15; i >= 0; i--) begin\n        if (remainder[16:8] < b_reg) begin\n            result[i] = 0;\n        end else begin\n            result[i] = 1;\n            remainder[16:9] = remainder[16:9] - b_reg;\n        end\n        remainder = {1'b0, remainder[15:0], a_reg[7]};\n        a_reg = {a_reg[14:0], 1'b0};\n    end\nend\n\nassign odd = remainder;\n\nendmodule",
        "model": "qwen2.5-coder:7b",
        "quality_score": 0.85,
        "layer_idx": 0,
        "cached_at": "2026-02-03T16:06:01.448338",
        "generation_info": {
          "layer_idx": 0,
          "prompt_type": "initial",
          "generation_time": "2026-02-03T16:05:52.617181"
        }
      },
      {
        "code": "module div_16bit (\n    input [15:0] A,\n    input [7:0]  B,\n    output reg [15:0] result,\n    output reg [15:0] odd\n);\nreg [3:0] quotient;\nreg [12:0] remainder;\n\nalways @(*) begin\n    a_reg <= A;\n    b_reg <= B;\nend\n\nalways @(*) begin\n    quotient = 0;\n    remainder = A;\n    for (int i = 15; i >= 8; i--) begin\n        if (remainder[i:i+7] >= b_reg) begin\n            remainder[i-8:i] -= b_reg << (i - 7);\n            quotient[i/4] = 1;\n        end\n    end\n    result = {quotient, a_reg[3:0]};\n    odd = remainder;\nend\n\nendmodule",
        "model": "qwen2.5-coder:7b",
        "quality_score": 0.6,
        "layer_idx": 0,
        "cached_at": "2026-02-03T16:06:01.448341",
        "generation_info": {
          "layer_idx": 0,
          "prompt_type": "initial",
          "generation_time": "2026-02-03T16:05:56.769322"
        }
      },
      {
        "code": "module div_16bit (\n    input [15:0] A,\n    input [7:0] B,\n    output reg [15:0] result,\n    output reg [15:0] odd\n);\n\nreg [15:0] a_reg;\nreg [7:0] b_reg;\n\nalways @(A or B) begin\n    a_reg <= A;\n    b_reg <= B;\nend\n\nalways @(a_reg or b_reg) begin\n    if (a_reg >= b_reg) begin\n        result = (result << 1) | 1;\n        odd = a_reg - b_reg;\n    end else begin\n        result = result << 1;\n        odd = a_reg;\n    end\nend\n\nendmodule",
        "model": "qwen2.5-coder:7b",
        "quality_score": 0.84,
        "layer_idx": 0,
        "cached_at": "2026-02-03T16:06:01.448342",
        "generation_info": {
          "layer_idx": 0,
          "prompt_type": "initial",
          "generation_time": "2026-02-03T16:06:01.448325"
        }
      }
    ],
    "1": [
      {
        "code": "module div_16bit (\n    input  [15:0] A,\n    input  [7:0] B,\n    output reg [15:0] result,\n    output reg [15:0] odd\n);\n\nreg [15:0] a_reg;\nreg [7:0] b_reg;\nreg [16:0] quotient;\nreg [16:0] remainder;\n\nalways @(*) begin\n    a_reg = A;\n    b_reg = B;\nend\n\nalways @(*) begin\n    quotient = 0;\n    remainder = a_reg;\n    for (int i = 15; i >= 8; i--) begin\n        if (remainder[i+7:i] >= b_reg) begin\n            remainder[i-7:i] -= b_reg;\n            quotient[i/4] = 1;\n        end\n    end\n    result = {quotient, a_reg[3:0]};\n    odd = remainder;\nend\n\nendmodule",
        "model": "qwen2.5-coder:7b",
        "quality_score": 0.6,
        "layer_idx": 1,
        "cached_at": "2026-02-03T16:06:17.690080",
        "generation_info": {
          "layer_idx": 1,
          "prompt_type": "aggregation",
          "input_codes_quality": [
            0.85,
            0.84,
            0.6
          ],
          "generation_time": "2026-02-03T16:06:06.172836"
        }
      },
      {
        "code": "module div_16bit (\n    input  [15:0] A,\n    input  [7:0] B,\n    output reg [15:0] result,\n    output reg [15:0] odd\n);\n\nreg [15:0] a_reg;\nreg [7:0] b_reg;\nreg [16:0] quotient;\nreg [16:0] remainder;\n\nalways @(*) begin\n    a_reg = A;\n    b_reg = B;\nend\n\nalways @(*) begin\n    quotient = 0;\n    remainder = 0;\n    for (int i = 15; i >= 8; i--) begin\n        if (remainder[16:9] < b_reg) begin\n            result[i-8:i] = 0;\n        end else begin\n            result[i-8:i] = 1;\n            remainder[16:9] = remainder[16:9] - b_reg;\n        end\n        remainder = {1'b0, remainder[15:0], a_reg[7]};\n        a_reg = {a_reg[14:0], 1'b0};\n    end\nend\n\nassign odd = remainder;\n\nendmodule",
        "model": "qwen2.5-coder:7b",
        "quality_score": 0.6,
        "layer_idx": 1,
        "cached_at": "2026-02-03T16:06:17.690082",
        "generation_info": {
          "layer_idx": 1,
          "prompt_type": "aggregation",
          "input_codes_quality": [
            0.85,
            0.84,
            0.6
          ],
          "generation_time": "2026-02-03T16:06:12.049471"
        }
      },
      {
        "code": "module div_16bit (\n    input [15:0] A,\n    input [7:0] B,\n    output reg [15:0] result,\n    output reg [15:0] odd\n);\n\nreg [15:0] a_reg;\nreg [7:0] b_reg;\nreg [16:0] quotient;\nreg [16:0] remainder;\n\nalways @(*) begin\n    a_reg = A;\n    b_reg = B;\nend\n\nalways @(*) begin\n    quotient = 0;\n    remainder = 0;\n    for (int i = 15; i >= 7; i--) begin\n        if (remainder[16:8] < b_reg) begin\n            result[i-7:i] = 0;\n        end else begin\n            result[i-7:i] = 1;\n            remainder[16:9] = remainder[16:9] - b_reg;\n        end\n        remainder = {1'b0, remainder[15:0], a_reg[7]};\n        a_reg = {a_reg[14:0], 1'b0};\n    end\nend\n\nassign odd = remainder;\n\nendmodule",
        "model": "qwen2.5-coder:7b",
        "quality_score": 0.6,
        "layer_idx": 1,
        "cached_at": "2026-02-03T16:06:17.690083",
        "generation_info": {
          "layer_idx": 1,
          "prompt_type": "aggregation",
          "input_codes_quality": [
            0.85,
            0.84,
            0.6
          ],
          "generation_time": "2026-02-03T16:06:17.690066"
        }
      }
    ],
    "2": [
      {
        "code": "module div_16bit (\n    input  [15:0] A,\n    input  [7:0] B,\n    output reg [15:0] result,\n    output reg [15:0] odd\n);\n\nreg [15:0] a_reg;\nreg [7:0] b_reg;\nreg [16:0] quotient;\nreg [16:0] remainder;\n\nalways @(A or B) begin\n    a_reg = A;\n    b_reg = B;\nend\n\nalways @(a_reg or b_reg) begin\n    quotient = 0;\n    remainder = {8'b0, a_reg};\n    for (int i = 15; i >= 0; i--) begin\n        if (remainder[i+7:i] >= b_reg) begin\n            remainder[i+7:i] -= b_reg;\n            quotient[i] = 1;\n        end\n        remainder = {1'b0, remainder[16:1], a_reg[7]};\n        a_reg = {a_reg[14:0], 1'b0};\n    end\nend\n\nassign odd = {remainder[8:1], a_reg};\n\nendmodule",
        "model": "qwen2.5-coder:7b",
        "quality_score": 0.6,
        "layer_idx": 2,
        "cached_at": "2026-02-03T16:06:33.479366",
        "generation_info": {
          "layer_idx": 2,
          "prompt_type": "aggregation",
          "input_codes_quality": [
            0.85,
            0.84,
            0.6
          ],
          "generation_time": "2026-02-03T16:06:23.213724"
        }
      },
      {
        "code": "module div_16bit (\n    input  [15:0] A,\n    input  [7:0] B,\n    output reg [15:0] result,\n    output reg [15:0] odd\n);\n\nreg [15:0] a_reg;\nreg [7:0] b_reg;\nreg [16:0] quotient;\nreg [16:0] remainder;\n\nalways @(*) begin\n    a_reg = A;\n    b_reg = B;\nend\n\nalways @(*) begin\n    quotient = 0;\n    remainder = a_reg;\n    for (int i = 15; i >= 8; i--) begin\n        if (remainder[i:i+7] >= b_reg) begin\n            remainder[i-8:i] -= b_reg << (i - 7);\n            quotient |= 1 << (i / 4);\n        end\n    end\n    result = {quotient, a_reg[3:0]};\n    odd = remainder;\nend\n\nendmodule",
        "model": "qwen2.5-coder:7b",
        "quality_score": 0.6,
        "layer_idx": 2,
        "cached_at": "2026-02-03T16:06:33.479368",
        "generation_info": {
          "layer_idx": 2,
          "prompt_type": "aggregation",
          "input_codes_quality": [
            0.85,
            0.84,
            0.6
          ],
          "generation_time": "2026-02-03T16:06:28.326178"
        }
      },
      {
        "code": "module div_16bit (\n    input  [15:0] A,\n    input  [7:0] B,\n    output reg [15:0] result,\n    output reg [15:0] odd\n);\n\nreg [15:0] a_reg;\nreg [7:0] b_reg;\nreg [16:0] quotient;\nreg [16:0] remainder;\n\nalways @(A or B) begin\n    a_reg <= A;\n    b_reg <= B;\n    quotient = 0;\n    remainder = {8'b0, a_reg};\n    for (int i = 15; i >= 0; i--) begin\n        if (remainder[16:9] >= b_reg) begin\n            result[i] = 1;\n            remainder[16:9] = remainder[16:9] - b_reg;\n        end else begin\n            result[i] = 0;\n        end\n    end\n    odd = remainder[15:0];\nend\n\nendmodule",
        "model": "qwen2.5-coder:7b",
        "quality_score": 0.85,
        "layer_idx": 2,
        "cached_at": "2026-02-03T16:06:33.479370",
        "generation_info": {
          "layer_idx": 2,
          "prompt_type": "aggregation",
          "input_codes_quality": [
            0.85,
            0.84,
            0.6
          ],
          "generation_time": "2026-02-03T16:06:33.479352"
        }
      }
    ]
  },
  "metadata": {
    "last_updated": "2026-02-03T16:06:33.479375",
    "total_hdl_codes": 9
  }
}