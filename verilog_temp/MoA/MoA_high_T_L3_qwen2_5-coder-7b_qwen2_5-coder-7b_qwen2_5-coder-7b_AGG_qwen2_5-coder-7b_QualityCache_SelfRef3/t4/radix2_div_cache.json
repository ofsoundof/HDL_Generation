{
  "design_name": "radix2_div",
  "trial_num": 4,
  "created_at": "2026-02-03T16:17:44.122275",
  "total_layers": 3,
  "layer_outputs": {
    "0": [
      {
        "code": "module radix2_div (\n    input wire clk,\n    input wire rst,\n    input wire sign,\n    input wire [7:0] dividend,\n    input wire [7:0] divisor,\n    input wire opn_valid,\n    output reg res_valid,\n    output reg [15:0] result\n);\n\nreg signed [8:0] sr;\nreg signed [8:0] neg_divisor;\nreg [2:0] cnt;\nreg start_cnt;\n\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        res_valid <= 0;\n        sr <= 0;\n        neg_divisor <= 0;\n        cnt <= 0;\n        start_cnt <= 0;\n        result <= 0;\n    end else begin\n        if (opn_valid && !res_valid) begin\n            sr <= {1'b0, dividend};\n            neg_divisor <= -divisor;\n            cnt <= 1;\n            start_cnt <= 1;\n        end else if (start_cnt) begin\n            if (cnt == 8) begin\n                cnt <= 0;\n                start_cnt <= 0;\n                result <= {sr[7:0], sr[8]};\n            end else begin\n                cnt <= cnt + 1;\n                neg_divisor <= neg_divisor << 1;\n                if (sr >= neg_divisor) begin\n                    sr <= sr - neg_divisor;\n                    sr[8] <= 1;\n                end else begin\n                    sr[8] <= 0;\n                end\n            end\n        end\n\n        if (cnt == 0 && start_cnt == 0) begin\n            res_valid <= 1;\n        end else begin\n            res_valid <= 0;\n        end\n    end\nend\n\nendmodule",
        "model": "qwen2.5-coder:7b",
        "quality_score": 0.59,
        "layer_idx": 0,
        "cached_at": "2026-02-03T16:18:11.852689",
        "generation_info": {
          "layer_idx": 0,
          "prompt_type": "initial",
          "generation_time": "2026-02-03T16:17:52.045678"
        }
      },
      {
        "code": "module radix2_div(\n    input clk,\n    input rst,\n    input sign,\n    input [7:0] dividend,\n    input [7:0] divisor,\n    input opn_valid,\n    output reg res_valid,\n    output reg [15:0] result\n);\n\n    reg [7:0] abs_dividend, abs_divisor;\n    reg [8:0] SR;\n    reg [3:0] cnt;\n    reg start_cnt;\n    reg [7:0] NEG_DIVISOR;\n    wire sub_result;\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            res_valid <= 0;\n            SR <= 0;\n            cnt <= 0;\n            start_cnt <= 0;\n            result <= 0;\n        end else begin\n            if (opn_valid && !res_valid) begin\n                abs_dividend <= sign ? ((dividend[7] == 1'b1) ? ~dividend + 1 : dividend) << 1 : dividend << 1;\n                abs_divisor <= sign ? ((divisor[7] == 1'b1) ? ~divisor + 1 : divisor) : divisor;\n                NEG_DIVISOR <= ~abs_divisor + 1;\n                cnt <= 1;\n                start_cnt <= 1;\n            end else if (start_cnt) begin\n                if (cnt == 8) begin\n                    SR[0] <= abs_dividend[7];\n                    SR[9:8] <= result[15:14];\n                    res_valid <= 1;\n                    cnt <= 0;\n                    start_cnt <= 0;\n                end else begin\n                    sub_result <= SR[7:0] >= NEG_DIVISOR;\n                    if (sub_result) begin\n                        SR[7:0] <= SR[7:0] - NEG_DIVISOR;\n                        result[cnt + 8] <= 1;\n                    end else begin\n                        result[cnt + 8] <= 0;\n                    end\n                    SR <= {SR[9], sub_result, SR[7:1]};\n                    cnt <= cnt + 1;\n                end\n            end\n        end\n    end\n\nendmodule",
        "model": "qwen2.5-coder:7b",
        "quality_score": 0.6,
        "layer_idx": 0,
        "cached_at": "2026-02-03T16:18:11.852692",
        "generation_info": {
          "layer_idx": 0,
          "prompt_type": "initial",
          "generation_time": "2026-02-03T16:18:01.688555"
        }
      },
      {
        "code": "module radix2_div (\n    input clk,\n    input rst,\n    input sign,\n    input [7:0] dividend,\n    input [7:0] divisor,\n    input opn_valid,\n    output reg res_valid,\n    output reg [15:0] result\n);\n\nreg [8:0] SR;\nreg [7:0] NEG_DIVISOR;\nreg start_cnt;\nreg [2:0] cnt;\n\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        res_valid <= 0;\n        SR <= 9'b0;\n        NEG_DIVISOR <= 8'b0;\n        start_cnt <= 0;\n        cnt <= 3'b0;\n        result <= 16'b0;\n    end else begin\n        if (opn_valid && ~res_valid) begin\n            SR <= ({dividend[7], dividend} << 1);\n            NEG_DIVISOR <= {~sign, ~divisor + 1};\n            start_cnt <= 1;\n            cnt <= 3'b0;\n        end else if (start_cnt && ~opn_valid) begin\n            if (cnt == 8'b1000) begin\n                start_cnt <= 0;\n                SR[9:1] <= {result[7], result};\n                SR[0] <= 1'b0;\n                cnt <= 3'b0;\n            end else begin\n                SR[9] <= SR[8];\n                SR[8:0] <= SR[7:0] - NEG_DIVISOR;\n                if (SR[9]) begin\n                    SR[8:0] <= SR[7:0] + NEG_DIVISOR;\n                end\n                cnt <= cnt + 1'b1;\n            end\n        end\n    end\nend\n\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        res_valid <= 0;\n    end else begin\n        if (~start_cnt && ~opn_valid && SR[9] == 1'b0) begin\n            result <= {SR[8:0], cnt};\n            res_valid <= 1;\n        end else if (opn_valid || start_cnt) begin\n            res_valid <= 0;\n        end\n    end\nend\n\nendmodule",
        "model": "qwen2.5-coder:7b",
        "quality_score": 0.6,
        "layer_idx": 0,
        "cached_at": "2026-02-03T16:18:11.852693",
        "generation_info": {
          "layer_idx": 0,
          "prompt_type": "initial",
          "generation_time": "2026-02-03T16:18:11.852675"
        }
      }
    ],
    "1": [
      {
        "code": "module radix2_div (\n    input wire clk,\n    input wire rst,\n    input wire sign,\n    input wire [7:0] dividend,\n    input wire [7:0] divisor,\n    input wire opn_valid,\n    output reg res_valid,\n    output reg [15:0] result\n);\n\nreg signed [8:0] sr;\nreg signed [7:0] neg_divisor;\nreg [2:0] cnt;\nreg start_cnt;\n\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        res_valid <= 0;\n        sr <= 0;\n        neg_divisor <= 0;\n        cnt <= 0;\n        start_cnt <= 0;\n        result <= 0;\n    end else begin\n        if (opn_valid && !res_valid) begin\n            sr <= sign ? ((dividend[7] == 1'b1) ? -dividend : dividend) << 1 : dividend << 1;\n            neg_divisor <= sign ? -divisor : divisor;\n            cnt <= 3'b001;\n            start_cnt <= 1;\n        end else if (start_cnt && !opn_valid) begin\n            if (cnt == 8'b1000) begin\n                sr[9:1] <= {result[7], result};\n                sr[0] <= 1'b0;\n                cnt <= 3'b000;\n                start_cnt <= 0;\n                res_valid <= 1;\n            end else begin\n                sr[9] <= sr[8];\n                if (sr[9]) begin\n                    sr[8:0] <= sr[7:0] + neg_divisor;\n                end else begin\n                    sr[8:0] <= sr[7:0] - neg_divisor;\n                    result[cnt + 8] <= 1;\n                end\n                cnt <= cnt + 1'b1;\n            end\n        end\n\n        if (cnt == 3'b000 && start_cnt == 0) begin\n            res_valid <= 1;\n        end else begin\n            res_valid <= 0;\n        end\n    end\nend\n\nendmodule",
        "model": "qwen2.5-coder:7b",
        "quality_score": 0.5399999999999999,
        "layer_idx": 1,
        "cached_at": "2026-02-03T16:18:42.099514",
        "generation_info": {
          "layer_idx": 1,
          "prompt_type": "aggregation",
          "input_codes_quality": [
            0.6,
            0.6,
            0.59
          ],
          "generation_time": "2026-02-03T16:18:21.651465"
        }
      },
      {
        "code": "module radix2_div (\n    input clk,\n    input rst,\n    input sign,\n    input [7:0] dividend,\n    input [7:0] divisor,\n    input opn_valid,\n    output reg res_valid,\n    output reg [15:0] result\n);\n\nreg signed [8:0] sr;\nreg signed [8:0] neg_divisor;\nreg [2:0] cnt;\nreg start_cnt;\n\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        res_valid <= 0;\n        sr <= 0;\n        neg_divisor <= 0;\n        cnt <= 0;\n        start_cnt <= 0;\n        result <= 0;\n    end else begin\n        if (opn_valid && !res_valid) begin\n            sr <= {1'b0, sign ? ((dividend[7] == 1'b1) ? ~dividend + 1 : dividend) << 1 : dividend};\n            neg_divisor <= sign ? -((divisor[7] == 1'b1) ? ~divisor + 1 : divisor) << 1 : (divisor << 1);\n            cnt <= 3'b0;\n            start_cnt <= 1;\n        end else if (start_cnt && !opn_valid) begin\n            if (cnt == 8'b1000) begin\n                start_cnt <= 0;\n                sr[9:1] <= {result[7], result};\n                cnt <= 3'b0;\n            end else begin\n                sr[9] <= SR[8];\n                sr[8:0] <= SR[7:0] - neg_divisor;\n                if (SR[9]) begin\n                    sr[8:0] <= SR[7:0] + neg_divisor;\n                end\n                cnt <= cnt + 1'b1;\n            end\n        end\n\n        if (cnt == 0 && start_cnt == 0) begin\n            res_valid <= 1;\n        end else begin\n            res_valid <= 0;\n        end\n    end\nend\n\nendmodule",
        "model": "qwen2.5-coder:7b",
        "quality_score": 0.6,
        "layer_idx": 1,
        "cached_at": "2026-02-03T16:18:42.099517",
        "generation_info": {
          "layer_idx": 1,
          "prompt_type": "aggregation",
          "input_codes_quality": [
            0.6,
            0.6,
            0.59
          ],
          "generation_time": "2026-02-03T16:18:31.556845"
        }
      },
      {
        "code": "module radix2_div (\n    input clk,\n    input rst,\n    input sign,\n    input [7:0] dividend,\n    input [7:0] divisor,\n    input opn_valid,\n    output reg res_valid,\n    output reg [15:0] result\n);\n\nreg signed [8:0] sr;\nreg signed [8:0] abs_dividend, abs_divisor;\nreg signed [8:0] neg_divisor;\nreg [2:0] cnt;\nreg start_cnt;\n\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        res_valid <= 0;\n        sr <= 0;\n        abs_dividend <= 0;\n        abs_divisor <= 0;\n        neg_divisor <= 0;\n        cnt <= 0;\n        start_cnt <= 0;\n        result <= 0;\n    end else begin\n        if (opn_valid && !res_valid) begin\n            abs_dividend <= sign ? ((dividend[7] == 1'b1) ? ~dividend + 1 : dividend) << 1 : dividend << 1;\n            abs_divisor <= sign ? ((divisor[7] == 1'b1) ? ~divisor + 1 : divisor) : divisor;\n            neg_divisor <= -abs_divisor;\n            cnt <= 1;\n            start_cnt <= 1;\n        end else if (start_cnt && !opn_valid) begin\n            if (cnt == 8) begin\n                sr[0] <= abs_dividend[7];\n                sr[9:8] <= result[15:14];\n                res_valid <= 1;\n                cnt <= 0;\n                start_cnt <= 0;\n            end else begin\n                if (sr >= neg_divisor) begin\n                    sr <= sr - neg_divisor;\n                    sr[8] <= 1;\n                end else begin\n                    sr[8] <= 0;\n                end\n                sr <= {sr[9], sr[8], sr[7:1]};\n                cnt <= cnt + 1;\n            end\n        end\n\n        if (cnt == 0 && start_cnt == 0) begin\n            result <= {sr[8:0], sr[7]};\n        end else begin\n            res_valid <= 0;\n        end\n    end\nend\n\nendmodule",
        "model": "qwen2.5-coder:7b",
        "quality_score": 0.69,
        "layer_idx": 1,
        "cached_at": "2026-02-03T16:18:42.099518",
        "generation_info": {
          "layer_idx": 1,
          "prompt_type": "aggregation",
          "input_codes_quality": [
            0.6,
            0.6,
            0.59
          ],
          "generation_time": "2026-02-03T16:18:42.099502"
        }
      }
    ],
    "2": [
      {
        "code": "module radix2_div(\n    input clk,\n    input rst,\n    input sign,\n    input [7:0] dividend,\n    input [7:0] divisor,\n    input opn_valid,\n    output reg res_valid,\n    output reg [15:0] result\n);\n\nreg [8:0] SR;\nreg [7:0] abs_dividend, abs_divisor;\nreg [7:0] neg_divisor;\nreg [2:0] cnt;\nreg start_cnt;\nwire sub_result;\n\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        res_valid <= 0;\n        SR <= 9'b0;\n        abs_dividend <= 8'b0;\n        abs_divisor <= 8'b0;\n        neg_divisor <= 8'b0;\n        cnt <= 3'b0;\n        start_cnt <= 0;\n        result <= 16'b0;\n    end else begin\n        if (opn_valid && !res_valid) begin\n            abs_dividend <= sign ? ((dividend[7] == 1'b1) ? ~dividend + 1 : dividend) << 1 : dividend << 1;\n            abs_divisor <= sign ? ((divisor[7] == 1'b1) ? ~divisor + 1 : divisor) : divisor;\n            neg_divisor <= -abs_divisor;\n            cnt <= 3'b001;\n            start_cnt <= 1;\n        end else if (start_cnt && !opn_valid) begin\n            if (cnt == 8'b1000) begin\n                SR[9:1] <= {result[7], result};\n                SR[0] <= abs_dividend[7];\n                res_valid <= 1;\n                cnt <= 3'b000;\n                start_cnt <= 0;\n            end else begin\n                sub_result <= SR[8:0] >= neg_divisor;\n                SR[9] <= SR[8];\n                if (sub_result) begin\n                    SR[8:0] <= SR[8:0] - neg_divisor;\n                    result[cnt + 8] <= 1;\n                end else begin\n                    result[cnt + 8] <= 0;\n                end\n                SR <= {SR[9], sub_result, SR[7:1]};\n                cnt <= cnt + 3'b001;\n            end\n        end\n    end\nend\n\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        res_valid <= 0;\n    end else begin\n        if (!start_cnt && !opn_valid && SR[9] == 1'b0) begin\n            result <= {SR[8:0], cnt};\n            res_valid <= 1;\n        end else if (opn_valid || start_cnt) begin\n            res_valid <= 0;\n        end\n    end\nend\n\nendmodule",
        "model": "qwen2.5-coder:7b",
        "quality_score": 0.6,
        "layer_idx": 2,
        "cached_at": "2026-02-03T16:19:16.208089",
        "generation_info": {
          "layer_idx": 2,
          "prompt_type": "aggregation",
          "input_codes_quality": [
            0.69,
            0.6,
            0.6
          ],
          "generation_time": "2026-02-03T16:18:54.918551"
        }
      },
      {
        "code": "module radix2_div (\n    input clk,\n    input rst,\n    input sign,\n    input [7:0] dividend,\n    input [7:0] divisor,\n    input opn_valid,\n    output reg res_valid,\n    output reg [15:0] result\n);\n\nreg signed [8:0] sr;\nreg signed [8:0] abs_dividend, abs_divisor;\nreg signed [8:0] neg_divisor;\nreg [2:0] cnt;\nreg start_cnt;\n\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        res_valid <= 0;\n        sr <= 0;\n        abs_dividend <= 0;\n        abs_divisor <= 0;\n        neg_divisor <= 0;\n        cnt <= 0;\n        start_cnt <= 0;\n        result <= 0;\n    end else begin\n        if (opn_valid && !res_valid) begin\n            abs_dividend <= sign ? ((dividend[7] == 1'b1) ? ~dividend + 1 : dividend) << 1 : dividend << 1;\n            abs_divisor <= sign ? ((divisor[7] == 1'b1) ? ~divisor + 1 : divisor) : divisor;\n            neg_divisor <= -abs_divisor;\n            cnt <= 1;\n            start_cnt <= 1;\n        end else if (start_cnt && !opn_valid) begin\n            if (cnt == 8) begin\n                sr[0] <= abs_dividend[7];\n                sr[9:8] <= result[15:14];\n                res_valid <= 1;\n                cnt <= 0;\n                start_cnt <= 0;\n            end else begin\n                if (sr >= neg_divisor) begin\n                    sr <= sr - neg_divisor;\n                    sr[8] <= 1;\n                end else begin\n                    sr[8] <= 0;\n                end\n                sr <= {sr[9], sr[8], sr[7:1]};\n                cnt <= cnt + 1;\n            end\n        end\n\n        if (cnt == 0 && start_cnt == 0) begin\n            result <= {sr[8:0], sr[7]};\n        end else begin\n            res_valid <= 0;\n        end\n    end\nend\n\nendmodule",
        "model": "qwen2.5-coder:7b",
        "quality_score": 0.69,
        "layer_idx": 2,
        "cached_at": "2026-02-03T16:19:16.208092",
        "generation_info": {
          "layer_idx": 2,
          "prompt_type": "aggregation",
          "input_codes_quality": [
            0.69,
            0.6,
            0.6
          ],
          "generation_time": "2026-02-03T16:19:05.474435"
        }
      },
      {
        "code": "module radix2_div(\n    input clk,\n    input rst,\n    input sign,\n    input [7:0] dividend,\n    input [7:0] divisor,\n    input opn_valid,\n    output reg res_valid,\n    output reg [15:0] result\n);\n\n    reg signed [8:0] SR;\n    reg signed [8:0] abs_dividend, abs_divisor;\n    reg signed [8:0] neg_divisor;\n    reg [2:0] cnt;\n    reg start_cnt;\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            res_valid <= 0;\n            SR <= 9'b0;\n            abs_dividend <= 0;\n            abs_divisor <= 0;\n            neg_divisor <= 0;\n            cnt <= 3'b0;\n            start_cnt <= 0;\n            result <= 16'b0;\n        end else begin\n            if (opn_valid && ~res_valid) begin\n                abs_dividend <= sign ? ((dividend[7] == 1'b1) ? ~dividend + 1 : dividend) << 1 : dividend << 1;\n                abs_divisor <= sign ? ((divisor[7] == 1'b1) ? ~divisor + 1 : divisor) : divisor;\n                neg_divisor <= -abs_divisor;\n                cnt <= 3'b001;\n                start_cnt <= 1;\n            end else if (start_cnt && ~opn_valid) begin\n                if (cnt == 8'b1000) begin\n                    SR[9:1] <= {result[7], result};\n                    SR[0] <= abs_dividend[7];\n                    res_valid <= 1;\n                    cnt <= 3'b000;\n                    start_cnt <= 0;\n                end else begin\n                    SR[8:0] <= SR[7:0] - neg_divisor;\n                    if (SR[9]) begin\n                        SR[8:0] <= SR[7:0] + neg_divisor;\n                        result[cnt + 8] <= 1;\n                    end else begin\n                        result[cnt + 8] <= 0;\n                    end\n                    SR <= {SR[9], SR[8:1]};\n                    cnt <= cnt + 3'b001;\n                end\n            end\n        end\n    end\n\nendmodule",
        "model": "qwen2.5-coder:7b",
        "quality_score": 0.69,
        "layer_idx": 2,
        "cached_at": "2026-02-03T16:19:16.208093",
        "generation_info": {
          "layer_idx": 2,
          "prompt_type": "aggregation",
          "input_codes_quality": [
            0.69,
            0.6,
            0.6
          ],
          "generation_time": "2026-02-03T16:19:16.208077"
        }
      }
    ]
  },
  "metadata": {
    "last_updated": "2026-02-03T16:19:16.208099",
    "total_hdl_codes": 9
  }
}