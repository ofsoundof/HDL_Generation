{
  "design_name": "radix2_div",
  "trial_num": 3,
  "created_at": "2026-02-03T16:16:14.430925",
  "total_layers": 3,
  "layer_outputs": {
    "0": [
      {
        "code": "module radix2_div (\n    input wire clk,\n    input wire rst,\n    input wire sign,\n    input wire [7:0] dividend,\n    input wire [7:0] divisor,\n    input wire opn_valid,\n    output reg res_valid,\n    output reg [15:0] result\n);\n\nreg signed [8:0] abs_dividend;\nreg signed [8:0] neg_divisor;\nwire signed [9:0] sub_result;\nreg [7:0] SR;\nreg [2:0] cnt;\nreg start_cnt;\n\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        SR <= 8'b0;\n        cnt <= 3'b0;\n        start_cnt <= 1'b0;\n        res_valid <= 1'b0;\n        result <= 16'b0;\n    end else begin\n        if (opn_valid && !res_valid) begin\n            abs_dividend <= sign ? -dividend : dividend;\n            neg_divisor <= sign ? -divisor : divisor;\n            SR <= {abs_dividend, 1'b0};\n            cnt <= 3'b0;\n            start_cnt <= 1'b1;\n        end else if (start_cnt) begin\n            if (cnt == 3'b100) begin\n                cnt <= 3'b0;\n                start_cnt <= 1'b0;\n                res_valid <= 1'b1;\n                result <= {SR[9:8], SR[7:0]};\n            end else begin\n                sub_result = SR - neg_divisor;\n                if (sub_result >= 0) begin\n                    SR <= {sub_result[8:0], 1'b1};\n                end else begin\n                    SR <= {sub_result[8:0], 1'b0};\n                end\n                cnt <= cnt + 3'b001;\n            end\n        end else if (res_valid) begin\n            res_valid <= 1'b0;\n        end\n    end\nend\n\nendmodule",
        "model": "qwen2.5-coder:7b",
        "quality_score": 0.6,
        "layer_idx": 0,
        "cached_at": "2026-02-03T16:16:40.892856",
        "generation_info": {
          "layer_idx": 0,
          "prompt_type": "initial",
          "generation_time": "2026-02-03T16:16:23.354372"
        }
      },
      {
        "code": "module radix2_div (\n    input wire clk,\n    input wire rst,\n    input wire sign,\n    input wire [7:0] dividend,\n    input wire [7:0] divisor,\n    input wire opn_valid,\n    output reg res_valid,\n    output reg [15:0] result\n);\n\nreg [15:0] SR;\nreg [7:0] NEG_DIVISOR;\nreg [2:0] cnt;\nreg start_cnt;\n\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        SR <= 16'b0;\n        NEG_DIVISOR <= 8'b0;\n        cnt <= 3'b0;\n        start_cnt <= 1'b0;\n        res_valid <= 1'b0;\n        result <= 16'b0;\n    end else begin\n        if (opn_valid && ~res_valid) begin\n            SR <= {(sign && dividend[7]) ? {8'b0, ~dividend + 1} : dividend << 1, 8'b0};\n            NEG_DIVISOR <= {(sign && divisor[7]) ? {8'b0, ~divisor + 1} : divisor};\n            cnt <= 3'b01;\n            start_cnt <= 1'b1;\n        end else if (start_cnt) begin\n            if (cnt == 3'b1000) begin\n                start_cnt <= 1'b0;\n                res_valid <= 1'b1;\n            end else begin\n                cnt <= cnt + 1;\n                SR[15:8] <= {(SR[15], ~((SR & 256) - NEG_DIVISOR)[7]) & SR[15:1]} << 1 | ((SR & 256) - NEG_DIVISOR)[7];\n            end\n        end else if (res_valid && ~opn_valid) begin\n            res_valid <= 1'b0;\n        end\n    end\nend\n\nassign result = SR;\n\nendmodule",
        "model": "qwen2.5-coder:7b",
        "quality_score": 0.6,
        "layer_idx": 0,
        "cached_at": "2026-02-03T16:16:40.892858",
        "generation_info": {
          "layer_idx": 0,
          "prompt_type": "initial",
          "generation_time": "2026-02-03T16:16:32.400142"
        }
      },
      {
        "code": "module radix2_div (\n    input wire clk,\n    input wire rst,\n    input wire sign,\n    input wire [7:0] dividend,\n    input wire [7:0] divisor,\n    input wire opn_valid,\n    output reg res_valid,\n    output reg [15:0] result\n);\n\n    reg [15:0] SR;\n    reg [7:0] ABS_DIVISOR, NEG_DIVISOR;\n    reg [2:0] cnt, start_cnt;\n    reg borrow;\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            result <= 16'b0;\n            SR <= 16'b0;\n            ABS_DIVISOR <= 8'b0;\n            NEG_DIVISOR <= 8'b0;\n            cnt <= 3'b0;\n            start_cnt <= 1'b0;\n            res_valid <= 1'b0;\n        end else begin\n            if (opn_valid && !res_valid) begin\n                ABS_DIVISOR <= sign ? {8'b0, dividend[7]} : {8'b0, dividend};\n                NEG_DIVISOR <= ~ABS_DIVISOR + 1;\n                SR <= {ABS_DIVISOR << 1, 1'b0};\n                cnt <= 3'b1;\n                start_cnt <= 1'b1;\n            end else if (start_cnt) begin\n                if (cnt == 8'd7) begin\n                    result <= {SR[7:0], SR[15:8]};\n                    start_cnt <= 1'b0;\n                    res_valid <= 1'b1;\n                end else begin\n                    borrow = SR[16] ? 1'b1 : 1'b0;\n                    SR <= {SR[15:8], borrow};\n                    cnt <= cnt + 1'd1;\n                end\n            end\n        end\n    end\n\nendmodule",
        "model": "qwen2.5-coder:7b",
        "quality_score": 0.45,
        "layer_idx": 0,
        "cached_at": "2026-02-03T16:16:40.892860",
        "generation_info": {
          "layer_idx": 0,
          "prompt_type": "initial",
          "generation_time": "2026-02-03T16:16:40.892843"
        }
      }
    ],
    "1": [
      {
        "code": "module radix2_div (\n    input wire clk,\n    input wire rst,\n    input wire sign,\n    input wire [7:0] dividend,\n    input wire [7:0] divisor,\n    input wire opn_valid,\n    output reg res_valid,\n    output reg [15:0] result\n);\n\nreg signed [8:0] abs_dividend;\nreg signed [8:0] neg_divisor;\nwire signed [9:0] sub_result;\nreg [7:0] SR;\nreg [2:0] cnt;\nreg start_cnt;\n\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        SR <= 8'b0;\n        cnt <= 3'b0;\n        start_cnt <= 1'b0;\n        res_valid <= 1'b0;\n        result <= 16'b0;\n    end else begin\n        if (opn_valid && !res_valid) begin\n            abs_dividend <= sign ? -dividend : dividend;\n            neg_divisor <= sign ? -divisor : divisor;\n            SR <= {abs_dividend, 1'b0};\n            cnt <= 3'b0;\n            start_cnt <= 1'b1;\n        end else if (start_cnt) begin\n            if (cnt == 3'b100) begin\n                cnt <= 3'b0;\n                start_cnt <= 1'b0;\n                res_valid <= 1'b1;\n                result <= {SR[9:8], SR[7:0]};\n            end else begin\n                sub_result = SR - neg_divisor;\n                if (sub_result >= 0) begin\n                    SR <= {sub_result[8:0], 1'b1};\n                end else begin\n                    SR <= {sub_result[8:0], 1'b0};\n                end\n                cnt <= cnt + 3'b001;\n            end\n        end else if (res_valid) begin\n            res_valid <= 1'b0;\n        end\n    end\nend\n\nendmodule",
        "model": "qwen2.5-coder:7b",
        "quality_score": 0.6,
        "layer_idx": 1,
        "cached_at": "2026-02-03T16:17:07.226521",
        "generation_info": {
          "layer_idx": 1,
          "prompt_type": "aggregation",
          "input_codes_quality": [
            0.6,
            0.6,
            0.45
          ],
          "generation_time": "2026-02-03T16:16:49.799015"
        }
      },
      {
        "code": "module radix2_div (\n    input wire clk,\n    input wire rst,\n    input wire sign,\n    input wire [7:0] dividend,\n    input wire [7:0] divisor,\n    input wire opn_valid,\n    output reg res_valid,\n    output reg [15:0] result\n);\n\nreg signed [8:0] abs_dividend;\nreg signed [8:0] neg_divisor;\nwire signed [9:0] sub_result;\nreg [7:0] SR;\nreg [2:0] cnt;\nreg start_cnt;\n\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        SR <= 8'b0;\n        cnt <= 3'b0;\n        start_cnt <= 1'b0;\n        res_valid <= 1'b0;\n        result <= 16'b0;\n    end else begin\n        if (opn_valid && !res_valid) begin\n            abs_dividend <= sign ? -dividend : dividend;\n            neg_divisor <= sign ? -divisor : divisor;\n            SR <= {abs_dividend, 1'b0};\n            cnt <= 3'b0;\n            start_cnt <= 1'b1;\n        end else if (start_cnt) begin\n            if (cnt == 3'b100) begin\n                start_cnt <= 1'b0;\n                res_valid <= 1'b1;\n                result <= {SR[9:8], SR[7:0]};\n            end else begin\n                sub_result = SR - neg_divisor;\n                SR <= {sub_result[8:0], (sub_result >= 0 ? 1'b1 : 1'b0)};\n                cnt <= cnt + 3'b001;\n            end\n        end\n    end\nend\n\nendmodule",
        "model": "qwen2.5-coder:7b",
        "quality_score": 0.6,
        "layer_idx": 1,
        "cached_at": "2026-02-03T16:17:07.226523",
        "generation_info": {
          "layer_idx": 1,
          "prompt_type": "aggregation",
          "input_codes_quality": [
            0.6,
            0.6,
            0.45
          ],
          "generation_time": "2026-02-03T16:16:57.837207"
        }
      },
      {
        "code": "module radix2_div (\n    input wire clk,\n    input wire rst,\n    input wire sign,\n    input wire [7:0] dividend,\n    input wire [7:0] divisor,\n    input wire opn_valid,\n    output reg res_valid,\n    output reg [15:0] result\n);\n\nreg signed [8:0] abs_dividend;\nreg signed [8:0] neg_divisor;\nwire signed [9:0] sub_result;\nreg [7:0] SR;\nreg [2:0] cnt;\nreg start_cnt;\n\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        SR <= 8'b0;\n        cnt <= 3'b0;\n        start_cnt <= 1'b0;\n        res_valid <= 1'b0;\n        result <= 16'b0;\n    end else begin\n        if (opn_valid && !res_valid) begin\n            abs_dividend <= sign ? -dividend : dividend;\n            neg_divisor <= sign ? -divisor : divisor;\n            SR <= {abs_dividend, 1'b0};\n            cnt <= 3'b0;\n            start_cnt <= 1'b1;\n        end else if (start_cnt) begin\n            if (cnt == 3'b100) begin\n                cnt <= 3'b0;\n                start_cnt <= 1'b0;\n                res_valid <= 1'b1;\n                result <= {SR[9:8], SR[7:0]};\n            end else begin\n                sub_result = SR - neg_divisor;\n                if (sub_result >= 0) begin\n                    SR <= {sub_result[8:0], 1'b1};\n                end else begin\n                    SR <= {sub_result[8:0], 1'b0};\n                end\n                cnt <= cnt + 3'b001;\n            end\n        end else if (res_valid) begin\n            res_valid <= 1'b0;\n        end\n    end\nend\n\nendmodule",
        "model": "qwen2.5-coder:7b",
        "quality_score": 0.6,
        "layer_idx": 1,
        "cached_at": "2026-02-03T16:17:07.226524",
        "generation_info": {
          "layer_idx": 1,
          "prompt_type": "aggregation",
          "input_codes_quality": [
            0.6,
            0.6,
            0.45
          ],
          "generation_time": "2026-02-03T16:17:07.226505"
        }
      }
    ],
    "2": [
      {
        "code": "module radix2_div (\n    input wire clk,\n    input wire rst,\n    input wire sign,\n    input wire [7:0] dividend,\n    input wire [7:0] divisor,\n    input wire opn_valid,\n    output reg res_valid,\n    output reg [15:0] result\n);\n\nreg signed [8:0] abs_dividend;\nreg signed [8:0] neg_divisor;\nwire signed [9:0] sub_result;\nreg [7:0] SR;\nreg [2:0] cnt;\nreg start_cnt;\n\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        SR <= 8'b0;\n        cnt <= 3'b0;\n        start_cnt <= 1'b0;\n        res_valid <= 1'b0;\n        result <= 16'b0;\n    end else begin\n        if (opn_valid && !res_valid) begin\n            abs_dividend <= sign ? -dividend : dividend;\n            neg_divisor <= sign ? -divisor : divisor;\n            SR <= {abs_dividend, 1'b0};\n            cnt <= 3'b0;\n            start_cnt <= 1'b1;\n        end else if (start_cnt) begin\n            if (cnt == 3'b100) begin\n                cnt <= 3'b0;\n                start_cnt <= 1'b0;\n                res_valid <= 1'b1;\n                result <= {SR[9:8], SR[7:0]};\n            end else begin\n                sub_result = SR - neg_divisor;\n                if (sub_result >= 0) begin\n                    SR <= {sub_result[8:0], 1'b1};\n                end else begin\n                    SR <= {sub_result[8:0], 1'b0};\n                end\n                cnt <= cnt + 3'b001;\n            end\n        end else if (res_valid) begin\n            res_valid <= 1'b0;\n        end\n    end\nend\n\nendmodule",
        "model": "qwen2.5-coder:7b",
        "quality_score": 0.6,
        "layer_idx": 2,
        "cached_at": "2026-02-03T16:17:34.401287",
        "generation_info": {
          "layer_idx": 2,
          "prompt_type": "aggregation",
          "input_codes_quality": [
            0.6,
            0.6,
            0.6
          ],
          "generation_time": "2026-02-03T16:17:16.345713"
        }
      },
      {
        "code": "module radix2_div (\n    input wire clk,\n    input wire rst,\n    input wire sign,\n    input wire [7:0] dividend,\n    input wire [7:0] divisor,\n    input wire opn_valid,\n    output reg res_valid,\n    output reg [15:0] result\n);\n\nreg signed [8:0] abs_dividend;\nreg signed [8:0] neg_divisor;\nwire signed [9:0] sub_result;\nreg [7:0] SR;\nreg [2:0] cnt;\nreg start_cnt;\n\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        SR <= 8'b0;\n        cnt <= 3'b0;\n        start_cnt <= 1'b0;\n        res_valid <= 1'b0;\n        result <= 16'b0;\n    end else begin\n        if (opn_valid && !res_valid) begin\n            abs_dividend <= sign ? -dividend : dividend;\n            neg_divisor <= sign ? -divisor : divisor;\n            SR <= {abs_dividend, 1'b0};\n            cnt <= 3'b0;\n            start_cnt <= 1'b1;\n        end else if (start_cnt) begin\n            if (cnt == 3'b100) begin\n                cnt <= 3'b0;\n                start_cnt <= 1'b0;\n                res_valid <= 1'b1;\n                result <= {SR[9:8], SR[7:0]};\n            end else begin\n                sub_result = SR - neg_divisor;\n                if (sub_result >= 0) begin\n                    SR <= {sub_result[8:0], 1'b1};\n                end else begin\n                    SR <= {sub_result[8:0], 1'b0};\n                end\n                cnt <= cnt + 3'b001;\n            end\n        end else if (res_valid) begin\n            res_valid <= 1'b0;\n        end\n    end\nend\n\nendmodule",
        "model": "qwen2.5-coder:7b",
        "quality_score": 0.6,
        "layer_idx": 2,
        "cached_at": "2026-02-03T16:17:34.401290",
        "generation_info": {
          "layer_idx": 2,
          "prompt_type": "aggregation",
          "input_codes_quality": [
            0.6,
            0.6,
            0.6
          ],
          "generation_time": "2026-02-03T16:17:25.131191"
        }
      },
      {
        "code": "module radix2_div (\n    input wire clk,\n    input wire rst,\n    input wire sign,\n    input wire [7:0] dividend,\n    input wire [7:0] divisor,\n    input wire opn_valid,\n    output reg res_valid,\n    output reg [15:0] result\n);\n\nreg signed [8:0] abs_dividend;\nreg signed [8:0] neg_divisor;\nwire signed [9:0] sub_result;\nreg [7:0] SR;\nreg [2:0] cnt;\nreg start_cnt;\n\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        SR <= 8'b0;\n        cnt <= 3'b0;\n        start_cnt <= 1'b0;\n        res_valid <= 1'b0;\n        result <= 16'b0;\n    end else begin\n        if (opn_valid && !res_valid) begin\n            abs_dividend <= sign ? -dividend : dividend;\n            neg_divisor <= sign ? -divisor : divisor;\n            SR <= {abs_dividend, 1'b0};\n            cnt <= 3'b0;\n            start_cnt <= 1'b1;\n        end else if (start_cnt) begin\n            if (cnt == 3'b100) begin\n                cnt <= 3'b0;\n                start_cnt <= 1'b0;\n                res_valid <= 1'b1;\n                result <= {SR[9:8], SR[7:0]};\n            end else begin\n                sub_result = SR - neg_divisor;\n                if (sub_result >= 0) begin\n                    SR <= {sub_result[8:0], 1'b1};\n                end else begin\n                    SR <= {sub_result[8:0], 1'b0};\n                end\n                cnt <= cnt + 3'b001;\n            end\n        end else if (res_valid) begin\n            res_valid <= 1'b0;\n        end\n    end\nend\n\nendmodule",
        "model": "qwen2.5-coder:7b",
        "quality_score": 0.6,
        "layer_idx": 2,
        "cached_at": "2026-02-03T16:17:34.401291",
        "generation_info": {
          "layer_idx": 2,
          "prompt_type": "aggregation",
          "input_codes_quality": [
            0.6,
            0.6,
            0.6
          ],
          "generation_time": "2026-02-03T16:17:34.401273"
        }
      }
    ]
  },
  "metadata": {
    "last_updated": "2026-02-03T16:17:34.401298",
    "total_hdl_codes": 9
  }
}